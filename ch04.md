# 正規表現とパイプ
Linuxを理解するために、重要な知識がこの正規表現とパイプです。正規表現はLinuxのさまざまな処理で使われることが多いですので、しっかり理解してください。

## 標準入出力
前章では、さまざまなコマンドを利用しました。それぞれのコマンドはひとつのプログラムです。Linuxのプログラムには、「1つの入り口と2つの出口」があります。それを、それぞれ標準入力・標準出力・標準エラー出力といいます。

標準入力はプログラムに入ってくるデータのことを示します。標準入力先は一般的にはキーボードになっています。
標準出力はプログラムの実行結果を書き出す先のことを示します。標準出力は一般的にはプログラムを実行した端末のディスプレイになっています。
標準エラー出力はエラーメッセージを書き出す先のことを示します。標準エラー出力は一般的にはプログラムを実行した端末のディスプレイになっています。

例えばlsとコマンドを打った場合、カレントディレクトリのファイルとディクトリの一覧が画面上に表示されます。このようにコマンドを実行した結果が画面上に表示されることを「標準出力に出力された」と表現します。

![標準入出力](image/Ch3/linuxtext2-img04.png){width=70%}

## リダイレクト
標準出力は通常コンソールに表示されますが、リダイレクトを使うとファイルに書き込むことができます。リダイレクトは「>」を使って表します。

### 出力のリダイレクト
次のコマンドはlsの結果を出力をリダイレクトして、ファイルに書き込む例です。「>」の記号を用いることでリダイレクトができます。

ls > ls-output

コマンドを実行するとls-output というファイルが作成されます。catコマンドで、ファイルls-outputの中身を確認してください。lsを実行したときと同じ内容が含まれています。このようにリダイレクトを用いると、出力先を変更しファイルに出力を格納することができます。


○実習: ファイルへのリダイレクト


実際にlsの結果をls-outputに出力してみましょう。

cd /etcls > ~/ls-outputcat ~/ls-output

ls-outputというファイルが作成されてその中にlsの出力結果が保存されました。すでにls-outputが存在しているときは、前のls-outputが削除されて新しいls-outputが作成されます。上書きせず追記したい場合は、アペンド(>>)の記号を用います。

### catコマンドによるファイル作成

前項では、標準出力をリダイレクトすることでファイルを作成しました。catコマンドとリダイレクトを組み合わせると、自由な内容でファイルを作成することができます。


○実習: catコマンドによるファイル作成


前の説明でファイルの内容表示に使ったcatコマンドでもリダイレクトを使うことでファイルの作成を行なうことができます。早速実行してみましょう。

cat > cat-outputHello
This is cat redirect.
（「Ctrl」Dを押す）
$


「Ctrl」DはEOF(End Of File)を示すキーで、データ入力の終わりを示します。Linuxではデータの読み込みが最後になると、このEOFが入力され終わる決まりがあります。catはEOFを受け取ったことで入力が終わったと判断し、リダイレクトを終了します。


## 標準エラー出力

コンピュータを操作しているとさまざまなエラーが起きることがあります。エラーは画面とログに出力されます。

例えば以下のコマンドを実行する場合を考えてみましょう。
実行例ではtekitouというディレクトリの内容をls-l-ouputというファイルに出力しようとしています。

ls -l tekitou > ls-l-output（tekitouというディレクトリ内の詳細出力をls-l-outputにリダイレクト）
ls: cannot access tekitou: そのようなファイルやディレクトリはありません
（tekitouというディレクトリが見つからなかったというエラーメッセージ）


しかし、tekitouというディレクトリが存在しなかった場合、「そのようなファイルやディレクトリはありません」といったエラーメッセージが標準出力されます。

このようにエラーメッセージは通常は標準出力されますが、リダイレクトを用いて任意のファイルにファイル出力することもできます。 

ls -l tekitou 2> ls-l-output（エラー出力をls-l-outputにリダイレクト）


この場合、エラーメッセージは画面に現れず、指定したファイルに出力されます。
コマンド中で指定している"2"は、標準エラー出力を示しています。標準出力は"1"を指定します。標準出力と標準エラー出力を1つのファイルに出力したい場合、次のように入力します。

ls -l tekitou > ls-l-output-second 2>&1
標準出力とエラー出力をls-l-output-secondにリダイレクトしました。
ファイルの指定と、1,2の指定の位置を間違えないようにしてください。


## パイプ
標準入力からデータを入れることにより、特別な処理ができるコマンドがあります。次のコマンドを入力してみましょう。

ls -l /usr/bin

画面にファイル一覧が流れますが/usr/binにはコマンドが1000以上あるため、そのままではすべてのコマンドを画面に表示しきることができません。ここで、次のように入力します。

ls -l /usr/bin | less

lessは前章で学習したページャのlessコマンドのことです。コマンドとコマンドを「|（パイプ）」でつなげることでパイプの前のコマンドを後ろのコマンドの標準入力とすることができます。

GNOMEなどのデスクトップ環境がインストールされている場合は、端末上でカーソルキーを押すことでページングすることができるため、操作する端末が目の前にある場合は、ページャにパイプで繋ぐ必要はあまりないかもしれません。しかし端末をリモート操作している場合やデスクトップ環境がインストールされていないLinux環境の場合は、パイプでつなげる方法を知っておくと大変便利です。

![パイプ](image/Ch3/linuxtext2-img05.png){width=70%}

標準エラー出力で説明した、標準出力と標準エラー出力を1つのファイルに出力する場合の方法も利用可能です。次のように入力してください。

ls -l xxx /usr/bin 2>&1 | less

xxxは存在しませんが、その旨のメッセージはリダイレクトにより標準出力に出力されます。


○実習: コマンドの実行結果をlessコマンドでページング表示


/usr/binのファイル一覧をlessでページングしながら表示します。

ls -l /usr/bin | less	:
	:	操作
	:
（qを入力して終了）

本章では、基本的なコマンドとして touch, head, tail, sort, uniq, tr, diffを学習します。主にテキストファイルを処理するために利用すると便利なコマンドです。

## ファイルのタイムスタンプの変更(touch)

ファイルには、タイムスタンプ（最終更新日）が必ず存在します。タイムスタンプはlsコマンドの-lオプションを付けることで確認できます。その最終更新時間を変更するのが、touchコマンドです。

書式
touch [オプション] ファイル名


touchコマンドを実行すると、ファイルのタイムスタンプが現在日時に変更されます。なお、オプションにより、新しいタイムスタンプとなる日時を指定することもできます。ファイルが存在しない場合、touchコマンドは中身が空である0バイトのファイルを作成します。


○実習: ファイルのタイムスタンプの変更と確認


テスト用のファイルを作成して、作成したファイルのタイムスタンプを変更してみましょう。早速以下のコマンドを実行してください。

$ ls -l hosts.bak}
-rw-rw-r-- 1 okada okada 187 Jun 4 10:06 hosts.bak
$ touch hosts.bak}
$ ls -l hosts.bak}
-rw-rw-r-- 1 okada okada 187 Jun 5 09:50 hosts.bak
$ touch -t 06030800 hosts.bak}
$ ls -l hosts.bak}
-rw-rw-r-- 1 okada okada 187 Jun 3 08:00 hosts.bak


-tはファイルの更新時刻を指定するオプションです。時間は@<tt>{[[CC]YY]MMDDhhmm[.SS]}形式（@<tt>{[]}内は省略可）で指定します。これで、ファイルの最終更新時刻が変わったことが確認できます。


○実習: touchコマンドによるファイル作成


touchコマンドはタイムスタンプの変更をするだけのコマンドではありません。touchコマンドで、指定したファイル名のファイルが存在しない場合、空のファイルを作成します。
$ ls -l touched-file}
$ touch touched-file}
$ ls -l touched-file}
-rw-rw-r-- 1 okada okada    0 Jun 5 09:55 touched-file


ファイルが作成されました。ファイルの中身は空なので、サイズが0バイトになっています。


## ファイルの一部の取得(head, tail)

ファイルの先頭や末尾など一部分のみを見る場合はheadコマンドやtailコマンドが使えます。
これらのコマンドを実行することでファイルの内容の一部を見ることができます。

### head

書式
head [オプション] ファイル名


オプション
-n 行
先頭から指定した行を標準出力します。
-c バイト
先頭から指定したバイト分を標準出力します。


headはファイルの先頭部分を標準出力します。オプションを付けない場合は、先頭から10行を標準出力します。

ファイル名には対象のファイル名を入力します。ファイル名の部分を空白にした場合、もしくは-（ハイフン）を指定した場合は、標準入力からのデータに対して処理を行ないます。従って次のコマンドを実行した場合、3つのコマンドの実行結果は同一になります。

実行例
$ head FILE}           FILEの先頭10行を表示
$ cat FILE | head -}   標準入力からの内容のうち先頭10行表示
$ cat FILE | head}     標準入力からの内容のうち先頭10行表示


3つとも、FILEというファイルの先頭10行を表示します。コマンドを実行時に行数を指定しなかった場合は先頭10行が表示されます。オプションを付けることにより表示する行数を変更できます。


### tail

書式
tail [オプション] ファイル名


オプション
-n 行
末尾から指定した行を標準出力します。
-c バイト
末尾から指定したバイト分を標準出力します。


tailはファイルの終わり部分を標準出力します。オプションを付けない場合は、末尾から10行を標準出力します。

ファイル名には対象のファイル名を入力します。ファイル名の部分を空白にした場合、もしくは-（ハイフン）を指定した場合は、標準入力からのデータに対して処理を行ないます。従って次のコマンドを実行した場合、3つのコマンドの実行結果は同一になります。

実行例
$ tail FILE}           FILEの末尾10行を表示
$ cat FILE | tail -}   標準入力からの内容のうち末尾10行表示
$ cat FILE | tail}     標準入力からの内容のうち末尾10行表示


3つとも、FILEというファイルの末尾10行を表示します。コマンドを実行時に行数を指定しなかった場合は末尾10行が表示されます。オプションを付けることにより表示する行数を変更できます。

### 特別なオプション -f

tailは本来ファイルの終わり部分を表示するコマンドです。しかし、ファイルによっては、その終わり部分が随時変わることがあります。
tailには-fというオプションが存在します。-fオプションを付けることにより、変更をリアルタイムでモニタすることが可能です。
よく用いられる目的に、ログファイルのモニタがあげられます。ログとは、サービスの動作状況が出力されるファイルです。システムの変更やサービスの動作などでメッセージがログに記載されると、その内容が出力されます。

書式
tail -f ファイル名


リアルタイムでログファイルなどの変更を見ることが可能です。


○実習: tailコマンドの実行


実際にtailコマンドと-fオプションの働きを確認してみましょう。tailコマンドの動きを確認するために、あらかじめ以下のコマンドを入力してテストで使うためのコマンドを準備してください。

$ man less > ~/manual-less}


テスト用のファイルができたら、このファイルに対してtailコマンドを実行してみましょう。

$ tail manual-less}
       You may distribute under the terms of the Less License.

       [参考訳]
       Copyright (c) 1994-2000  Kazushi (Jam) Marukawa, 日本語化ルーチンのみ。
       この部分に関するコメントは jam@pobox.com へ送って下さい。
       このパッチは Less ライセンスの下で配布できる。



                           Version 358: 08 Jul 2000                    LESS(1)


manual-lessファイルの末尾10行が標準出力されます。


○実習: tail -nコマンドの実行


tailコマンドは-nオプションを付けて標準出力する行数を指定することができます。
以下の例は末尾5行を標準出力する例です。

$ tail -n 5 manual-less} 
       このパッチは Less ライセンスの下で配布できる。



                           Version 358: 08 Jul 2000                    LESS(1)



○実習: tail -fコマンドの実行


最後に-fオプションを付けてファイルを開いてみましょう。

 1. 作成したmanual-lessをtail -fコマンドで開きます。
$ tail -f manual-less}
（略）
                           Version 358: 08 Jul 2000                    LESS(1)


 1. tailコマンドに-fオプションを付けたため、ファイルの終わり部分が標準出力されますが、シェルに制御が戻りません。
//indepimage[tail-1][][latex::width=0.8\maxwidth]


 1. 「アプリケーション→システム→端末」をクリックして端末をもう一つ開いてください。
//indepimage[tail-2][][latex::width=0.8\maxwidth]


 1. 新しい端末で以下のようにコマンドを実行します。
$ echo 'Hello' >> manual-less}

//indepimage[tail-3][][latex::width=0.8\maxwidth]


 1. manual-less ファイルにデータが追加されます。
$ tail -f manual-less
（略）
                           Version 358: 08 Jul 2000                    LESS(1)
Hello}

//indepimage[tail-4][][latex::width=0.8\maxwidth]



新しい端末から入力した'Hello'という文字列が出力されています。tail -fによるファイルの読み込みは「Ctrl」Cキーを押して処理を中断するまで継続されます。

tail -fはこの実習から分かるように、ファイルを動的に読み込むことができます。Webサーバーのアクセスログやエラーログを見る場合に便利なコマンドです。



## テキストファイルのソート(sort)

テキストファイルの中身をソートするにはsortコマンドが使えます。オプションでどのような順序でソートするか指定することができます。

書式
sort [オプション] ファイル名


オプション
-r
逆順でソートする

-k n
n列目のデータをソートする

-n
数値としてソートする


### ファイルの準備

sortの機能を確認するために、サンプルとなるファイルを作成します。このファイルを元に、sortを動作させます。内容は、3人の名前と数値です。左から順に '名前, 名字, 点数'となっていると考えてください。

$ cat > score}
yoshinori kawazu  85
keiichi oka  70
toru minemura  100
(Control-dを押す)
$


### sortの実行

テストファイルの作成が終わったら、sortコマンドとオプションを付けてさまざまな条件でソートしてみましょう。


○実習: sortコマンドの実行


まずはオプションを付けずにソートしてみます。

$ sort score}
keiichi oka 70
toru minemura 100
yoshinori kawazu 85


オプションを特に付けない場合は各行の1文字目をアルファベット順（k→t→y）でソートされます。


○実習: -rオプションを付けた逆順によるソート


sortコマンドにオプション-rを付けた場合はどうなるでしょうか。

$ sort -r score}
yoshinori kawazu 85
toru minemura 100
keiichi oka 70


アルファベットの逆順（y→t→k）にソートされます。

### n列目のデータソート(-k)

「sortを実行する」では行の1文字目を鍵としてソートを行いました。これは名前でソートしているのと同じです。では、名字を鍵としてソートするにはどうしたら良いでしょうか？sortでは-kオプションを付けると、ソートの鍵として利用する列の番号を指定します。


○実習: -kオプションを付けたソート


名字順でソートしてみましょう。
2列目の名字を鍵としてソートするので、オプションに2を指定します。

$ sort -k 2 score}
yoshinori kawazu 85
toru minemura 100
keiichi oka 70


2列目の名字の部分を基準にソートされます(k→m→o)。


○実習: さまざまなオプションを付けたソート


オプションとしてさらに-rを指定すると、逆順でソートできます。

$ sort -k 2 -r score}
keiichi oka 70
toru minemura 100
yoshinori kawazu 85


-rを指定したことで先ほどの逆順でソートされました(o→m→k)。

### 数値式でのソート

今度は得点の列(3列目)を鍵としてソートしてみましょう。コマンドは次のようになります。

実行例
$ sort -k 3 score}
toru minemura 100
keiichi oka 70
yoshinori kawazu 85


並び方が少し変ですね。大きい順で並ぶのであれば100→85→70になるべきですし、小さい順で並ぶのであれば70→85→100になるべきです。しかし、実行例のような結果になるのは、これら3つの数字が「文字として」認識されているからです。sortは前述の通り、1文字目しかみていません。従ってアルファベットをソートしたのと同様に、数値も最初の1文字を見てソートしています(1→7→8)。

これを辞書式ソートといって、文字を辞書に出てくる順にソートできます。アルファベットであればそれでかまいませんが、3列目は得点＝数値であり、得点順にソートする場合はこの辞書式ソートは不適切です。
これに対して、数値としてソートするのを数値式ソートといい、sortに-nオプションを付けることで実行できます。


○実習: 数値式ソートの実行


それでは早速数値式ソートを実践してみます。
文字列の3列目を基準として数値式ソートしましょう。

$ sort -n -k 3 score}
keiichi oka 70
yoshinori kawazu 85
toru minemura 100


リストが得点の低い順にソートされました。


○実習: 数値式ソートの実行(逆順)


オプションにさらに-rを付加すると、逆順でソートすることができます。

$ sort -n -r -k 3 score}
toru minemura 100
yoshinori kawazu 85
keiichi oka 70


-rを付加したことにより、得点の高い順にソートすることができました。


## 行の重複の消去(uniq)

uniqコマンドを使うことで直前の行と同じ内容があった場合、対象行を出力しません。連続している同じ内容の行を、1行にまとめることができます。

書式
uniq ファイル名



○実習: uniq確認用のファイル作成


uniqコマンドの動きを確認するため、以下のような内容のファイルをuniq-sampleとして保存しておいてください。

$ cat > uniq-sample}
AAA
BBB
AAA
CCC
CCC
DDD



○実習: uniqコマンドの実行


作成したuniq-sampleに対して、uniqコマンドを早速実行してみましょう。

$ uniq uniq-sample}
AAA
BBB
AAA
CCC
DDD


uniqの実行により、重複して記述されていた文字列CCCが1行にまとめられました。このようにuniqコマンドを使うことで全データから重複しない要素だけをピックアップすることができます。AAAは2行ありますが、結果はそのまま出力されています。これは、AAAの行は連続していないため、uniqの処理対象にはならないためです。

## 文字列の置き換え(tr)

trコマンドを使って、標準入力からのデータを文字毎に置き換える(TRanslate)ことができます。

書式
tr 文字列1  文字列2


trコマンドは文字を文字毎に別の文字に置き換えることができます。置き換える元のデータは標準入力からのデータを対象にします。実行例で動きを説明しましょう。

実行例
$ cat FILE | tr abc ABC}


この例では以下のようなことを行ないます。

 * catコマンドでFILEを開く。
 * trコマンドでa,b,cをそれぞれA,B,Cに置き換える。


○実習 trコマンドによる置き換え


では、次の例を実行したらどういった結果になるでしょうか。実際にファイルを作成して実行してみてください。

### ファイルを作成

$ cat > translate}
Android
iPhone
Windows Phone
（「Ctrl」Dを押す。）


### 実行

$ cat translate | tr on ON}
ANdrOid
iPhONe
WiNdOws PhONe


trコマンドについて理解できたでしょうか。trコマンドに2つのパラメーターを渡すと、文字毎に指定した文字を別の文字に置き換えます。従って例題のファイルに含まれるoとnの文字が、大文字のOとNに置き換えられたというわけです。

trコマンドの結果は標準出力に出力されますが、以下のようにリダイレクトすればファイルに出力することもできます。

### trの結果をリダイレクトを使ったファイル出力

$ cat translate | tr on ON > translate2}
$ cat translate2}
ANdrOid
iPhONe
WiNdOws PhONe


ファイルtranslateには変更が記録されず、trの実行結果はファイルtranslate2にファイル出力されます。

## ファイルの比較(diff)

Linuxにはファイルを比較するコマンドがあります。主に使われる用途として、変更の有無を調べる場合に用いられます。
diffの結果は標準出力されますが、リダイレクトすればファイルに出力することもできます。

書式
diff [オプション] ファイル1 ファイル2


オプション
-c
context diff 形式で差分を出力します。

-u
unified diff 形式で差分を出力します。



実行例
$ diff file1 file2
$ diff -c file1 file2
$ diff -u file1 file2



○実習: diffコマンドの実行


diffコマンドの動きを確認するため、以下のように実際に異なるファイルのfile1とfile2を作成しておいてください。

$ echo "test text" > file1}
$ echo "test text" > file2}
$ echo "new line" >> file2}


ファイルが作成できたら、diffコマンドでファイルを比較してみましょう。

### diffコマンドによる比較

$ diff file1 file2}
1a2
> new line


### diff -uコマンドによる比較

$ diff -u file1 file2}
--- file1	2012-07-06 11:00:00.098086703 +0900
+++ file2	2012-07-06 12:00:00.394135769 +0900
@@ -1 +1,2 @@
 test text
+new line


### diff -cコマンドによる比較

$ diff -c file1 file2}
*** file1	2012-07-06 11:00:00.098086703 +0900
--- file2	2012-07-06 12:00:00.394135769 +0900
***************
*** 1 ****
--- 1,2 ----
  test text
+ new line


オプションを付けずにdiffコマンドを実行した場合は、異なる部分を標準出力します。
今回紹介したオプションを付けてdiffコマンドを実行した場合、ファイルの更新時刻を含めたより多くの差分情報が表示されます。

たとえばここで、file2の内容を別の文字列で上書きしてdiffコマンドを実行してみてください。

$ echo "overwrite text" > file2}
（file2を別の文字列で上書き）
$ echo "new line" >> file2}


file1とfile2の共通点はなくなりましたので、diffコマンドを使って比較すると以下のように標準出力されます。

### diffコマンドによる比較

$ diff file1 file2}
1c1,2
< test text
---
> overwrite text
> new line


3つの差分があると表示されていますが、少しわかりにくいですね。
今度はdiff -uコマンドで比較してみましょう。

### diff -uコマンドによる比較

$ diff -u file1 file2}
--- file1	2012-07-06 13:21:21.219249366 +0900
+++ file2	2012-07-06 13:26:51.664814277 +0900
@@ -1 +1,2 @@
-test text
+overwrite text
+new line


diff -uコマンドによる比較は、削除された行の頭にマイナス記号、追加された行にプラス記号が付加されて標準出力されます。
標準出力の結果から、file1とfile2の共通していた文字列である「test text」が削除され、新たに「overwrite test」と「new line」という行が差分追加されているということがわかります。オプション-u は文字列の増減が激しい、文書やプログラムのソースコードを比較する場合に有用であるといえます。


## 章末テスト



(1)sortコマンドの実行結果となるように、適切なオプションを付けなさい。

$ sort (          ) price

Digital Camera 9800
32-inch TV 49800
Blue-ray Recorder 59800


(2)uniq-sampleというファイルに対してuniqコマンドを実行したときの実行結果を答えなさい。

$ cat uniq-sample
red
red
blue
red
blue


(3)file1とfile2の内容の違いを比較するコマンドを記述しなさい。


(4)以下のコマンドを実行したところ、何も結果が表示されずコマンド待ち状態になりました。何が考えられるか答えなさい。

$ diff test1 test2
$


(5)パス /etcのlsコマンドの実行結果が保存されたファイルls-etcの終わり8行分を表示する場合のコマンドを記述しなさい。

$ (                ) ls-etc 
wpa_supplicant
xdg
xinetd.d
xml
yp.conf
yum
yum.conf
yum.repos.d




## grepコマンド
grepコマンドは、ファイルの中からデータを検索します。また、| grepとすることで、標準入力から入ったデータに対し検索を行なうことも可能です。

書式
grep [オプション] 検索条件 [指定ファイル]


指定ファイルの部分は、1つでもかまいませんし、*のようなワイルドカードを利用した複数ファイルの指定でも可能です。 ワイルドカードとは、不特定の文字列を表現するのに利用される記号のことです。
検索条件として、正規表現が用いられます。正規表現は、grepのみならずLinuxで用いられるパターンマッチや、多くのプログラミング言語でも利用されている、非常に重要な機能です。

### 正規表現
正規表現は文字列のみならず、意味のある記号を用いることで、高度な検索条件を与える表現方法です。主に用いられる記号は次の通りです。

正規表現で使われる記号と意味
| 記号 | 意味
|-|-
| ^ | 行頭を表す
| $ | 行末を表す
| . | 任意の一字を意味する
| * | 直前文字の0回以上の繰り返しを意味する
| [...] | ...の中の任意の一字を意味する
| [^...] | ...の文字が含まれないことを意味する
| \\ | 正規表現の記号をエスケープする

正規表現の利用例
|記号 | 意味
|-|-
| ^a | aで始まっている行
| b$ | bで終わっている行
| a.b | aとbの間に1文字入っている
| [ab]ab | aもしくはbに続くab(aab,bab)
| [^ab]ab | aもしくはbで始まらない(not)で、abが続くもの(例: xab, zab等)

○実習: grepコマンドの実行
grepコマンドを用いて、文字列の検索を行ないましょう。

/etcディレクトリにあるファイルでabcという文字列を含むものを検索するには、以下のようにコマンドを実行します。

grep abc /etc/*	:
/etc/services:abcvoice-port	3781/tcp


/etcディレクトリにあるファイルで行の先頭がxyではじまっているものを検索するには、以下のようにコマンドを実行します。

grep ^xy /etc/*}	
	:
/etc/services:xyplex-mux	173/tcp
	:

### さまざまな条件を用いたgrepコマンドの実行

大文字と小文字の区別に関する条件を指定したり、否定の条件を指定することができます。

オプション
-e
文字列を検索パターンとして扱う。

-i
検索パターンと入力ファイルの双方で、英大文字と小文字の区別を行わない。

-v
検索パターンとマッチしなかった行を選択する。

○実習: さまざまな条件を用いた grep コマンドの実行

grep コマンドにオプションを付けて文字列を検索してみましょう。/etcディレクトリにあるファイルについて、さまざまな条件で検索してみます。

grep abc /etc/*(/etcディレクトリにある、abc という文字列を含むファイル)
（略）
/etc/services:hostname        101/tcp         hostnames       # usually from sri-nic
/etc/services:hostname        101/udp         hostnames       # usually from sri-nic
（略）

grep -i hostname /etc/*(/etc ディレクトリにある、大文字または小文字の hostname という文字列を含むファイル) 

/etc/rc.sysinit:    HOSTNAME=localhost
（略）
/etc/rc.sysinit:     # Reset the hostname.
（略）

grep abc /etc/* | grep -v tcp(/etc ディレクトリにある、 abc という文字列を含むが tcp という文字列は含まないファイル)
（略）
/etc/services:abcvoice-port  3781/udp                # ABCvoice server port
（略）


先ほど表示された行（/etc/services:abcvoice-port	3781/tcp）が、tcpという除外の文字列を含むため、今回は表示されません。

### 標準出力にマッチさせる
grepコマンドはファイルの内容に一致させる以外に、標準入力からの入力をマッチさせることが可能です。

○実習: 標準出力の結果をgrepで検索
標準出力の結果をgrepで検索してみましょう。以下のコマンドを早速実行してみましょう。

/usr/binにあるコマンド一覧を出力します。今回の例ではgrep -e d$と指定したため、ファイル名がdで終わるファイルを/usr/binから検索しています。
$  ls /usr/bin/ | grep -e d$		:
		:
xxd
yppasswd
$
