# 正規表現とパイプ
Linuxを理解するために、重要な知識がこの正規表現とパイプです。正規表現はLinuxのさまざまな処理で使われることが多いですので、しっかり理解してください。

## 標準入出力
前章では、さまざまなコマンドを利用しました。それぞれのコマンドはひとつのプログラムです。Linuxのプログラムには、「1つの入り口と2つの出口」があります。それを、それぞれ標準入力・標準出力・標準エラー出力といいます。

標準入力はプログラムに入ってくるデータのことを示します。標準入力先は一般的にはキーボードになっています。
標準出力はプログラムの実行結果を書き出す先のことを示します。標準出力は一般的にはプログラムを実行した端末のディスプレイになっています。
標準エラー出力はエラーメッセージを書き出す先のことを示します。標準エラー出力は一般的にはプログラムを実行した端末のディスプレイになっています。

例えばlsとコマンドを打った場合、カレントディレクトリのファイルとディクトリの一覧が画面上に表示されます。このようにコマンドを実行した結果が画面上に表示されることを「標準出力に出力された」と表現します。

![標準入出力](image/Ch3/linuxtext2-img04.png){width=70%}

## リダイレクト
標準出力は通常コンソールに表示されますが、リダイレクトを使うとファイルに書き込むことができます。リダイレクトは「>」を使って表します。

### 出力のリダイレクト
次のコマンドはlsの結果を出力をリダイレクトして、ファイルに書き込む例です。「>」の記号を用いることでリダイレクトができます。

ls > ls-output

コマンドを実行するとls-output というファイルが作成されます。catコマンドで、ファイルls-outputの中身を確認してください。lsを実行したときと同じ内容が含まれています。このようにリダイレクトを用いると、出力先を変更しファイルに出力を格納することができます。


○実習: ファイルへのリダイレクト


実際にlsの結果をls-outputに出力してみましょう。

cd /etcls > ~/ls-outputcat ~/ls-output

ls-outputというファイルが作成されてその中にlsの出力結果が保存されました。すでにls-outputが存在しているときは、前のls-outputが削除されて新しいls-outputが作成されます。上書きせず追記したい場合は、アペンド(>>)の記号を用います。

### catコマンドによるファイル作成

前項では、標準出力をリダイレクトすることでファイルを作成しました。catコマンドとリダイレクトを組み合わせると、自由な内容でファイルを作成することができます。


○実習: catコマンドによるファイル作成


前の説明でファイルの内容表示に使ったcatコマンドでもリダイレクトを使うことでファイルの作成を行なうことができます。早速実行してみましょう。

cat > cat-outputHello
This is cat redirect.
（「Ctrl」Dを押す）
$


「Ctrl」DはEOF(End Of File)を示すキーで、データ入力の終わりを示します。Linuxではデータの読み込みが最後になると、このEOFが入力され終わる決まりがあります。catはEOFを受け取ったことで入力が終わったと判断し、リダイレクトを終了します。


## 標準エラー出力

コンピュータを操作しているとさまざまなエラーが起きることがあります。エラーは画面とログに出力されます。

例えば以下のコマンドを実行する場合を考えてみましょう。
実行例ではtekitouというディレクトリの内容をls-l-ouputというファイルに出力しようとしています。

ls -l tekitou > ls-l-output（tekitouというディレクトリ内の詳細出力をls-l-outputにリダイレクト）
ls: cannot access tekitou: そのようなファイルやディレクトリはありません
（tekitouというディレクトリが見つからなかったというエラーメッセージ）


しかし、tekitouというディレクトリが存在しなかった場合、「そのようなファイルやディレクトリはありません」といったエラーメッセージが標準出力されます。

このようにエラーメッセージは通常は標準出力されますが、リダイレクトを用いて任意のファイルにファイル出力することもできます。 

ls -l tekitou 2> ls-l-output（エラー出力をls-l-outputにリダイレクト）


この場合、エラーメッセージは画面に現れず、指定したファイルに出力されます。
コマンド中で指定している"2"は、標準エラー出力を示しています。標準出力は"1"を指定します。標準出力と標準エラー出力を1つのファイルに出力したい場合、次のように入力します。

ls -l tekitou > ls-l-output-second 2>&1
標準出力とエラー出力をls-l-output-secondにリダイレクトしました。
ファイルの指定と、1,2の指定の位置を間違えないようにしてください。


## パイプ
標準入力からデータを入れることにより、特別な処理ができるコマンドがあります。次のコマンドを入力してみましょう。

ls -l /usr/bin

画面にファイル一覧が流れますが/usr/binにはコマンドが1000以上あるため、そのままではすべてのコマンドを画面に表示しきることができません。ここで、次のように入力します。

ls -l /usr/bin | less

lessは前章で学習したページャのlessコマンドのことです。コマンドとコマンドを「|（パイプ）」でつなげることでパイプの前のコマンドを後ろのコマンドの標準入力とすることができます。

GNOMEなどのデスクトップ環境がインストールされている場合は、端末上でカーソルキーを押すことでページングすることができるため、操作する端末が目の前にある場合は、ページャにパイプで繋ぐ必要はあまりないかもしれません。しかし端末をリモート操作している場合やデスクトップ環境がインストールされていないLinux環境の場合は、パイプでつなげる方法を知っておくと大変便利です。

![パイプ](image/Ch3/linuxtext2-img05.png){width=70%}

標準エラー出力で説明した、標準出力と標準エラー出力を1つのファイルに出力する場合の方法も利用可能です。次のように入力してください。

ls -l xxx /usr/bin 2>&1 | less

xxxは存在しませんが、その旨のメッセージはリダイレクトにより標準出力に出力されます。


○実習: コマンドの実行結果をlessコマンドでページング表示


/usr/binのファイル一覧をlessでページングしながら表示します。

ls -l /usr/bin | less	:
	:	操作
	:
（qを入力して終了）


## grepコマンド
grepコマンドは、ファイルの中からデータを検索します。また、| grepとすることで、標準入力から入ったデータに対し検索を行なうことも可能です。

書式
grep [オプション] 検索条件 [指定ファイル]


指定ファイルの部分は、1つでもかまいませんし、*のようなワイルドカードを利用した複数ファイルの指定でも可能です。 ワイルドカードとは、不特定の文字列を表現するのに利用される記号のことです。
検索条件として、正規表現が用いられます。正規表現は、grepのみならずLinuxで用いられるパターンマッチや、多くのプログラミング言語でも利用されている、非常に重要な機能です。

### 正規表現
正規表現は文字列のみならず、意味のある記号を用いることで、高度な検索条件を与える表現方法です。主に用いられる記号は次の通りです。

正規表現で使われる記号と意味
| 記号 | 意味
|-|-
| ^ | 行頭を表す
| $ | 行末を表す
| . | 任意の一字を意味する
| * | 直前文字の0回以上の繰り返しを意味する
| [...] | ...の中の任意の一字を意味する
| [^...] | ...の文字が含まれないことを意味する
| \\ | 正規表現の記号をエスケープする

正規表現の利用例
|記号 | 意味
|-|-
| ^a | aで始まっている行
| b$ | bで終わっている行
| a.b | aとbの間に1文字入っている
| [ab]ab | aもしくはbに続くab(aab,bab)
| [^ab]ab | aもしくはbで始まらない(not)で、abが続くもの(例: xab, zab等)

○実習: grepコマンドの実行
grepコマンドを用いて、文字列の検索を行ないましょう。

/etcディレクトリにあるファイルでabcという文字列を含むものを検索するには、以下のようにコマンドを実行します。

grep abc /etc/*	:
/etc/services:abcvoice-port	3781/tcp


/etcディレクトリにあるファイルで行の先頭がxyではじまっているものを検索するには、以下のようにコマンドを実行します。

grep ^xy /etc/*}	
	:
/etc/services:xyplex-mux	173/tcp
	:

### さまざまな条件を用いたgrepコマンドの実行

大文字と小文字の区別に関する条件を指定したり、否定の条件を指定することができます。

オプション
-e
文字列を検索パターンとして扱う。

-i
検索パターンと入力ファイルの双方で、英大文字と小文字の区別を行わない。

-v
検索パターンとマッチしなかった行を選択する。

○実習: さまざまな条件を用いた grep コマンドの実行

grep コマンドにオプションを付けて文字列を検索してみましょう。/etcディレクトリにあるファイルについて、さまざまな条件で検索してみます。

grep abc /etc/*(/etcディレクトリにある、abc という文字列を含むファイル)
（略）
/etc/services:hostname        101/tcp         hostnames       # usually from sri-nic
/etc/services:hostname        101/udp         hostnames       # usually from sri-nic
（略）

grep -i hostname /etc/*(/etc ディレクトリにある、大文字または小文字の hostname という文字列を含むファイル) 

/etc/rc.sysinit:    HOSTNAME=localhost
（略）
/etc/rc.sysinit:     # Reset the hostname.
（略）

grep abc /etc/* | grep -v tcp(/etc ディレクトリにある、 abc という文字列を含むが tcp という文字列は含まないファイル)
（略）
/etc/services:abcvoice-port  3781/udp                # ABCvoice server port
（略）


先ほど表示された行（/etc/services:abcvoice-port	3781/tcp）が、tcpという除外の文字列を含むため、今回は表示されません。

### 標準出力にマッチさせる
grepコマンドはファイルの内容に一致させる以外に、標準入力からの入力をマッチさせることが可能です。

○実習: 標準出力の結果をgrepで検索
標準出力の結果をgrepで検索してみましょう。以下のコマンドを早速実行してみましょう。

/usr/binにあるコマンド一覧を出力します。今回の例ではgrep -e d$と指定したため、ファイル名がdで終わるファイルを/usr/binから検索しています。
$  @<b>{ls /usr/bin/ | grep -e d$		:
		:
xxd
yppasswd
$
