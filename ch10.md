= プロセス管理

3章では基本的なコマンドについて学習しました。本章では、もう少しLinuxの内部寄りの、プロセスについて学習していきましょう。

###[column] この章の内容

11.1 プロセスとは

11.2 スケジューリング

11.3 フォアグランドジョブとバックグラウンドジョブ

11.4 プロセスID

11.6 シグナル

11.6 top コマンドとpstreeコマンド

11.7 プロセス間通信

11.8 章末テスト

###[/column]


## プロセスとは

Linuxでは実行中のプログラム（アプリケーション）を管理する単位をプロセスと呼びます。
コマンドインタープリターであるシェル自身もプロセスです。下記にシェルからコマンドを実行した場合を例に、プロセスの親子関係とプロセス生成から消滅までの流れを説明します。

「ユーザがシェルからコマンドを実行すると、シェルは子プロセスとして自分の分身を作ります（これをforkと呼びます。）。次に、シェルは子プロセスにコマンドの実行（これをexecと呼びます。）を任せ、子プロセスの終了を待ちます。子プロセスはコマンドの実行を終えると親プロセスに終了を伝え、消滅します。親プロセスは子プロセスの終了を受け取り、シェルプロンプトを表示し、ユーザの次のコマンドに備えます。」

プロセスの基本的な状態遷移を理解することは、システム管理、アプリケーション開発などで発生する問題のトラブルシューティングに欠かせないので、しっかり学習しましょう。




## スケジューリング

Linux は、１つのCPUでも複数のユーザが同時にログインでき、複数のプロセスを同時に実行できる、マルチユーザ、マルチタスクのOSです。しかし、厳密には瞬間瞬間では、プロセスは１つしか実行されず、それぞれのプロセスの実行順序はLinuxのスケジューラによって管理されています。

各プロセスは Run Queue と呼ばれる待ち行列で待機し、自分がCPUを利用できる順番を待ちます。自分の順番が来るとCPUを使用することができ、一定時間（タイムスライス）だけ処理を前に進めます。一定の時間が超過すると、またキューで次のCPU使用機会を待つことになります。このようなスケジューリングをラウンドロビン方式と呼びますが、その他に FIFO(First In First Out)方式もあります。

各プロセスはキューで待機しますが、プロセスによっては優先度の高いもの、それほど高くないものもあります。
そのパラメータの一つにNice値があります。Nice値は、-20から19までの値を取り、-20が最も実行優先度が高く、19が最も低くなっています。nice コマンドにより実行優先度をプロセスに指定したり、実行中のプロセスについては、renice コマンドにより優先度を変更することができます。




## フォアグランドジョブとバックグラウンドジョブ

プロセスとよく似た管理単位としてジョブがあります。Linuxが実行中のプログラムを管理する単位であるプロセスに対して、ジョブはシェルが管理するプログラムの単位です。
シェルからコマンドを実行する場合、ジョブをフォアグラウンドとバックグランドに切り替える機能があります。
例えば、処理に時間のかかるジョブを実行した時に、何もせずジョブの完了を待つのではなく、その間に別の作業をしたり、進捗を確認したい場合があります。そんな時、ジョブをバックグラウンドで実行すれば、同じ端末から別のコマンドを実行することができます。
他にも、プログラムの編集作業を中断して、プログラムを試行し、また編集作業に戻る場合などに有効です。なぜなら、編集を中断した場合、編集のundoやredoが中断前後で継続できるからです。

コマンドをバックグラウンドで起動するには、コマンドの後ろに＆（アンパサンド）をつけて実行します。

$ my_heavy_script &

実行中のコマンドをバックグラウンドに切り替えるには、^Z（CTRL+Z)でサスペンドしてから、bgコマンドでバックグラウンドで実行を継続させます。fg コマンドでフォアグランドに戻すこともできます。
ジョブの状態は、jobsコマンドで確認することができます。

$ my_heavy_script
^Z
[1]+  Stopped                 my_heavy_script
$ jobs
[1]+  Stopped                 my_heavy_script
$ bg
[1]+ my_heavy_script &
$ jobs
[1]+  Running                 my_heavy_script &

 
○実習: 複数のジョブを実行して、切り替えを試してみましょう。
$ sleep 3600&       <- １時間（3600秒）スリープするプロセスです。１時間以内に試しましょう。
$ sleep 3601&
$ sleep 3602&
$ jobs
[1]   実行中               sleep 3600 &
[2]-  実行中               sleep 3601 &
[3]+  実行中               sleep 3602 &
$ %1            <- [1]のジョブをフォアグラウンドジョブにします
sleep 3600
^Z              <- CTRL+Z でフォアグラウンドジョブをサスペンドします
[1]+  停止                  sleep 3600
$ jobs
[1]+  停止                  sleep 3600
[2]   実行中               sleep 3601 &
[3]-  実行中               sleep 3602 &
$ %-            <- 「-」の付いたジョブをフォアグラウンドジョブにします
sleep 3602
^C			<- フォアグランドにあるジョブを停止します。
$ %%        <- 「+」のついたジョブをフォアグラウンドジョブにします
sleep 3600
^C			<- フォアグランドにあるジョブを停止します。
$ fg        <- この場合の fg は、fg %+, %+, %% と同じ動作になります
sleep 3601
^C			<- フォアグランドにあるジョブを停止します。


## プロセスID

Linuxのプロセスには一意のIDであるプロセスID(PID)が付与されます。
自身のPIDは $$ で取得できます。

$ echo $$
13592

書式
ps [オプション]

現在実行されているプロセスのスナップショットを表示します。


オプション
-A
全てのプロセスを選択する。-e と等しい。

e
コマンドの後に環境を表示する。

l, -l
長いフォーマット。-（ダッシュ）のあるなしで表示は異なる。

w, -w
出力幅を広げる。このオプションを 2つ指定すると、幅の制限がなくなる。



$ ps l
F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
0  1000 12832 12821  20   0 116180  2276 n_tty_ Ss+  pts/0      0:00 bash
0  1000 13592 13589  20   0 116460  2976 wait   Ss   pts/1      0:00 -bash
0  1000 31246 13592  20   0  45316  1476 -      R+   pts/1      0:00 ps l

ps に l オプションを指定すると、PIDだけでなくPPID（親プロセスのID）も表示されます。ps の親プロセスが bash であることがわかります。




## シグナル

Linuxには、プロセスにシグナルというイベントを送信してプロセスを制御する機能があります。シグナルには、シグナル番号およびシグナル名が割り当てられており、代表的なものに以下のシグナルがあります。

//tsize[20,20,80]
//table[tbl24][代表的なシグナル]{
シグナル番号	シグナル名	意味
---------------------------------------------------------------------------
1	HUP	ハングアップ(Hang Up) 
2	INT	割り込み(Interrupt)
3	QUIT	強制停止(Quit)。コアダンプ生成。
9	KILL	強制終了(Kill)
15	TERM	 終了(Terminate)。killコマンドのデフォルトシグナル。

ユーザがプロセスにシグナルを送信する方法は3つあります。

 * シェルに割り当てられたキーの入力	（例：^C, ^Z, ^¥ など）
 * kill コマンド				（例：kill -HUP PID, kill -SIGINT PID,  kill -9 PID など）
 * プログラムでkill()関数を呼ぶ		

例えば、実行中のコマンドを停止するためにキーボードの ^C を押下することがあります。シェルは^Cを解釈して、実行中のプロセスに SIGINT(Interrupt Signal: シグナル番号2）を送信し、受け取ったプロセスは終了します。
プログラムによっては、例えば、SIGINT を無視するなど、受け取ったシグナルによって挙動を制御するように作られたものもあります。


上記以外にもシグナルがあり、kill -l コマンドでシグナルの種類を表示することができます。
$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL
 5) SIGTRAP	 6) SIGABRT	 7) SIGEMT	 8) SIGFPE
 9) SIGKILL	10) SIGBUS	11) SIGSEGV	12) SIGSYS
13) SIGPIPE	14) SIGALRM	15) SIGTERM	16) SIGURG
17) SIGSTOP	18) SIGTSTP	19) SIGCONT	20) SIGCHLD
21) SIGTTIN	22) SIGTTOU	23) SIGIO	24) SIGXCPU
25) SIGXFSZ	26) SIGVTALRM	27) SIGPROF	28) SIGWINCH
29) SIGINFO	30) SIGUSR1	31) SIGUSR2


シグナルを理解するために、テスト用の無限ループするシェルスクリプトを作成し、試してみましょう。



○実習:無限ループするシェルスクリプトを作成します。


$ vi loop
#!/bin/bash
while /bin/true
do
	sleep 3600
done
:w
^Z
$ chmod 755 loop	←シェルスクリプトに実行権を付与します。
$ ./loop	← 3600秒（１時間）のスリープを無限に繰り返す処理のため、フォアグラウンドで実行すると、シェルプロンプトが戻ってきません。
^C 		←CTRL+Cを押すことで、INT(Interupt Signal)が送信され、loopを終了することができます。

次に先ほど作成したシェルスクリプト"loop" にtrap 処理を挿入します。
$ fg
vi loop
#!/bin/bash
trap ‘echo “...CTRL+C is pressed.”’ 2    # trap にてSIGINT(2) を受信した時に中止せず別の処理を実行
while /bin/true
do
	sleep 3600
done
:w
^Z
$ ./loop	←無限ループに入ったので、^Cを押しますが、プロンプトが戻ってきません。
^C...CTRL+C is pressed.
^C...CTRL+C is pressed.
^Z		←^Zでサスペンドして kill コマンドでデフォルトのTERMシグナル(Ternminate Signal:シグナル番号15)を送信します。
[1]+  Stopped                 ./loop
$  kill %%
[demo@localhost bin]$
[1]+  Killed                  ./loop		←終了しました。



○実習:パイプを使ったときのプロセス IDを見てみましょう。

[demo@localhost bin]$ vim pipe
tty=`tty | sed -e 's|/dev/||'`
ps alx | grep $tty | cat -n

[demo@localhost bin]$ sh pipe
     1	5  1000 18095 18091  20   0 145056  2216 poll_s S    ?          0:00 sshd: demo@pts/1
     2	0  1000 18097 18095  20   0 116472  3044 wait   Ss   pts/1      0:00 -bash
     3	0  1000 19622 18097  20   0  47612  4888 signal T    pts/1      0:00 vim pipe
     4	0  1000 19798 18097  20   0   9504  1288 wait   S+   pts/1      0:00 sh pipe
     5	0  1000 19802 19798  20   0  45316  1476 -      R+   pts/1      0:00 ps alx
     6	0  1000 19803 19798  20   0   9032   656 -      R+   pts/1      0:00 grep pts/1
     7	0  1000 19804 19798  20   0   4656   348 pipe_w S+   pts/1      0:00 cat -n

シェルである bash が sshd の子プロセスであること、vim とsh pipe が bash の子プロセスであること、
ps alx, grep pts/1, can -n が sh pipe の子プロセスであることがわかります。


○実習: ps alx を実行して、PIDが一番小さなプロセスが何か確認してみましょう。

（CentOS 7 の systemd の環境では、systemdがPID=1になっています。)
$ ps alx
F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
4     0     1     0  20   0 193628  4744 ep_pol Ss   ?          0:05 /usr/lib/systemd/systemd --switched-r
oot --system --deserialize 21
1     0     2     0  20   0      0     0 kthrea S    ?          0:00 [kthreadd]
1     0     3     2  20   0      0     0 smpboo S    ?          0:00 [ksoftirqd/0]
: : : :

参考： SysV init の環境で同様の確認をした結果を掲載します。init プロセスが PID=1になっています。

$ ps alx
F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
4     0     1     0  20   0  28824  4392 -      Ss   ?          1:36 /sbin/init
1     0     2     0  20   0      0     0 -      S    ?          0:02 [kthreadd]
1     0     3     2  20   0      0     0 -      S    ?          9:01 [ksoftirqd/0]
: : : :



○実習: 下記の手順でプロセスを終了してみましょう。

sleep コマンドを2つ、バックグラウンドで実行し、ps l で親子関係を確認しましょう。
例）
$ sleep 3600 &
$ sleep 3601 &
$ ps l
2つのsleepプロセス(PIDは1234と1235とする)に、kill コマンドで KILL シグナルを送信してみましょう。
$ kill -9 1234 1235   または kill -SIGKILL 1234 1235



○実習: stty -a コマンドで、シグナルとキーの割り当てを確認してみましょう。

$ stty -a
speed 9600 baud; rows 24; columns 106; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?; swtch = <undef>;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc ixany imaxbel -iutf8
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe -echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke




## top コマンドとpstreeコマンド

psコマンドの他にプロセスの状態を表示するコマンドとして top コマンドがあります。
top コマンドは実行中のプロセスの状態をダイナミックに表示します。CPUやメモリの使用率などでソートしたり、topから指定したプロセスにシグナルを送信することもできます。

また、プロセスの親子関係をツリー表示する pstreeというコマンドもあります。

○実習:実行中のシェルを起点として、プロセスをツリー状に表示してみましょう。

[demo@localhost bin]$ pstree $$
bash─┬─loop───sleep
     └─pstree

学習課題：top コマンドで、指定したプロセスにシグナルを送信してみましょう。




## プロセス間通信

Linux上である処理を完了するのに、１つのプロセスで完結する場合もありますが、複数のプロセスがコミュニケーションを取りながら同期したり、動作を変更して達成することが多々あります。これをプロセス間通信と呼びます。

先に学習したパイプやシグナルもLinuxの代表的なプロセス間通信の手法です。
その他に、下記の手法があります。


 * System V IPC (Inter Process Communication)
 ** 共有メモリ（shared memory)
 ** セマフォ(semaphore)
 ** メッセージキュー(message queue)
 * ソケット


それぞれ次のような特徴があります。

 * パイプ:　１つのプロセスの標準入出力をつなぎ替えます。パイプ（｜）の左側のコマンド（プロセス）の標準出力を右側のコマンド（プロセス）の標準入力につなぐことで、通信を実現します。

 * シグナル: 特定のシグナルの受信を持って特定の処理を開始するなど、同期を実現します。

 * 共有メモリ（shared memory): 特定のメモリ領域を複数のプロセスで共有することでメッセージの受け渡し等が行えます。

 * セマフォ(semaphore): 資源のロックを行い、複数のプロセス間で同時に書き込みをしたりしないよう排他処理を実現します。

 * メッセージキュー(message queue): キューにメッセージを格納しておき、複数のプロセス間での非同期の通信を実現します。

 * ソケット: ネットワーク経由のホスト間のプロセスでの通信を実現します。



