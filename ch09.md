= ネットワークの設定と管理

Linuxがネットワークにつながれたとき、必要とされる基礎知識と確認コマンドと設定を見ていきます。確認コマンドとしてpingコマンド、tracerouteコマンド、ipコマンド、nslookupコマンド、systemctlコマンドを説明します。

###[column] この章の内容

10.1 TCP/IPとは

10.1.1 ローカルエリアネットワークとワイドエリアネットワーク

10.1.2IPとは

10.1.3 TCPとUDPとは

10.2 IPアドレス

10.2.1 IPアドレスのクラス

10.2.2 プライベートIPアドレス

10.2.3 サブネットマスク

10.2.4 CIDR 表記

10.3 経路の確認

10.4 ネットワークの設定

10.4.1 ネットワークインターフェース

10.4.2 IPアドレスを確認

10.4.3 IPアドレスの設定ファイル

10.4.4 インターフェースの設定

10.5 ルーティングの確認

10.5.1 ルーティングの変更

10.6 DNSを使う設定

10.6.1 名前(FQDN)

10.7 ポート番号

10.8 サービスの確認

10.9 ネットワークセキュリティの設定

10.9.1 ファイアウォールの設定

10.10 章末テスト

###[/column]



## TCP/IPとは

コンピュータ間をケーブルや無線機能で接続したシステムをネットワークと呼びます。LinuxをOSに利用したコンピュータのほとんどはネットワークに接続して利用します。物理的なネットワークはコンピュータ間をツイストペアケーブルでつなぎます。最近では有線のネットワークに加えて無線機能を使って接続したり、有線と無線の混在したネットワークもあります。

### ローカルエリアネットワークとワイドエリアネットワーク

学校や自宅などの閉じられた複数のコンピュータを相互接続したネットワークをネットワークをローカルエリアネットワーク(LAN)と呼びます。離れた場所にあるLANとLANを結んだネットワークのことをワイドエリアネットワーク(WAN)と呼びます。
LANはコンピュータ同士をLANケーブルで結び、WANはLAN同士を通信回線で結びます。

//indepimage[linuxtext2-img13][][latex::width=0.8\maxwidth]



### IPとは

ネットワークでつながったコンピュータ同士の間では、決まった手順（プロトコル）に従ってデータを送受信しています。今日一般的に使われているイーサネット規格のネットワークはプロトコルとしてTCP/IPを利用しています。TCP/IPのIP(Internet Protocol：インターネット プロトコル)は手順の基本です。IPは送り先とデータからなるパケットを送るだけの簡単な仕組みです。pingコマンドでデータが送信され、データを受けた機器(サーバやルータなど)から確認メッセージかが返ってくるかを確認できます。

//indepimage[linuxtext2-img09][][latex::width=0.8\maxwidth]



書式
ping ターゲット
ターゲット(ホスト名やIPアドレス)にデータを送り、返答が戻るまでの時間を表示します。
-cオプションを付けて、pingを発行する回数を指定することもできます。



○実習: ローカルなマシンのIPアドレスの確認


まずは、LAN上にあるホストにpingコマンドを実行してみましょう。

$ ping 192.168.1.1}
（192.168.1.1へpingを送信）
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=30 time=1.01 ms
（1.01m秒で返答があった）
64 bytes from 192.168.1.1: icmp_seq=2 ttl=30 time=0.914 ms
（0.914m秒で返答があった）

（「Ctrl」 Cでpingコマンドを中止）

--- 192.168.1.1 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 0.914/0.966/1.018/0.052 ms



○実習: インターネットにつながるマシンで確認


pingコマンドに対してlpiのサーバからの返答があるか(返答時間も)を確認してください。pingを3回実施するため、-cオプションを付けてコマンドを実行します。

$ ping lpi.jp -c 3} 
PING lpi.jp (203.174.74.34) 56(84) bytes of data.
64 bytes from sv1.lpi.jp (203.174.74.34): icmp_seq=1 ttl=52 time=3.14 ms
64 bytes from sv1.lpi.jp (203.174.74.34): icmp_seq=2 ttl=52 time=6.87 ms
64 bytes from sv1.lpi.jp (203.174.74.34): icmp_seq=3 ttl=52 time=5.67 ms

--- lpi.jp ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2009ms
rtt min/avg/max/mdev = 3.142/5.229/6.873/1.556 ms


pingコマンドは「Ctrl」Cを押すと止まります。コンピュータによってはセキュリティ対策のため、pingコマンドに応答しない場合があります。

### TCPとUDPとは

TCP(Transmission Control Protocol)はIP(Internet Protocol)の仕組みを使ってデータを送る手順です。IPは読んで字のごとく、インターネットにおいて情報の伝達を行なう手順(プロトコル)です。TCPでは、データのまとまりを1つ受け取ると、すぐにデータの破損などのエラーを確認し、間違っている場合はデータの再送を依頼します。

UDP(User Datagram Protocol)はエラー確認やデータの再送制御は行いませんが（必要であれば上位のアプリケーションでそのような処理を実装する必要があります）、その分データを高速に送ることができるので、小さなデータや映像のような多少欠損しても問題なく、信頼性よりも速度を求められる通信に適しています。

## IPアドレス

TCP/IPでデータを送受信するには発送元と発送先の場所を表すアドレスが必要です。インターネットではIPv4(Internet Protocol version 4)とIPv6という2つのプロトコルが使われています。
IPv4では4バイト(16進数で8桁)で表せるアドレスで、4バイトのアドレスは1バイト(16進数で2桁)ごとで10進数に変換してでつないで表記します。プライベートなIPアドレスを除いたIPアドレスをグローバルなIPアドレスと呼びます。グローバルなIPアドレスはNIC(日本ではJPNIC)に管理されており、許可なく利用(設定)できません。

//indepimage[linuxtext2-img10][][latex::width=0.8\maxwidth]


### IPアドレスのクラス

IPv4で使われるIPアドレスはネットワークアドレスとホストアドレスをつなげた形となります。ネットワークアドレスは次の表のサブネットマスクのビットが立っている(255の様な)部分で、ホストアドレスはサブネットマスクのビットが立っていない(0)の部分です(サブネットマスクに関しては後述します)。IPアドレスは学校や会社などの組織に対して割り当てられるので、割り当てられた組織で使われる範囲は連続したアドレスです。ネットワークアドレスの長さにより、AからCのクラスがあり、クラスDやクラスEなどの特殊なクラスも予約されています(現状ではAからCのクラスが実用されます)。

ホストアドレスにおいて、ホスト部の全てのビットが0のアドレスはそのネットワーク自身のアドレスを示し、ホスト部の全てのビットが1のアドレスは、そのネットワーク内の全てのホストに届くブロードキャストアドレスという特殊なアドレスを示します。これらのアドレスは実際にコンピュータに割り当てることはできません。

//tsize[50,30,15,25]
//table[tbl16][IPアドレスのクラス]{
アドレスの範囲	サブネットマスク	クラス	IPアドレスの数
---------------------------------------------------------------------------
0.0.0.0～127.255.255.255	255.0.0.0	クラスA	16,777,216個
128.0.0.0～191.255.255.255	255.255.0.0	クラスB	65,536個
192.0.0.0～223.255.255.255	255.255.255.0	クラスC	256個
224.0.0.0～239.255.255.255	.	クラスD	.
240.0.0.0～255.255.255.255	.	クラスE	.



### プライベートIPアドレス

ローカルなネットワークで自由に利用可能なIPアドレスが用意されており、プライベートIPアドレスと呼びます。
プライベートIPアドレスは次のようになります。

//tsize[50,30,30]
//table[tbl17][プライベートIPアドレスとクラス]{
アドレスの範囲	サブネットマスク	クラス
---------------------------------------------------------------------------
10.0.0.0～10.255.255.255	255.0.0.0	クラスA
172.16.0.0～172.31.255.255	255.255.0.0	クラスB
192.168.0.0～192.168.255.255	255.255.255.0	クラスC



### サブネットマスク

IPアドレスのうち、ネットワークアドレスとホストアドレスを識別するための数値をサブネットマスクといいます。サブネットマスクは通信先ホストが同一ネットワークにいるかいないかの判断に使われます。
ネットワーク(IPアドレスの集まり)はサブネットマスクを変えることで、複数のネットワークに分けて、効率的にIPアドレスを利用できます。

//indepimage[linuxtext2-img11][][latex::width=0.8\maxwidth]

//indepimage[linuxtext2-img17][][latex::width=0.8\maxwidth]


### CIDR（サイダー）表記

IPアドレスのクラスを学習したばかりですが、最近よく使用されるようになったクラス分けをしない CIDR （Classless Inter-Domain Routing）表記について学習します。

すでに、前節の図にも使用されていますが、IPアドレスのネットワーク部とホスト部の境目を/（スラッシュ）の後に続くビット数で指定する方法です。

まず、表記の例を３つ下記に示します

 * 127.0.0.1/8
 ** IPアドレスの先頭から８ビットをネットワーク部として、残りの２４ビットをホスト部とした設定です。クラスＡと同じ扱いで、それぞれ下記となります。
 *** IP アドレス	: 127.0.0.1
 *** ネットマスク	: 255.0.0.0
 *** ネットワーク	: 127.0.0.0
 *** ブロードキャスト: 127.255.255.255
 *** アドレスの数	: 16,777,216 個 

 * 192.168.0.1/24
 ** IPアドレスの先頭から２４ビットをネットワーク部として、残りの８ビットをホスト部とした設定です。クラスＣと同じ扱いで、それぞれ下記となります。
 *** IP アドレス	: 192.168.0.1
 *** ネットマスク	: 255.255.255.0
 *** ネットワーク	: 192.168.0.0
 *** ブロードキャスト: 192.168.0.255
 *** アドレスの数	: 256 個

 * 192.168.0.1/28
 ** IPアドレスの先頭から２８ビットをネットワーク部として、残りの４ビットをホスト部とした設定です。クラスＣのサブセットの扱いで、それぞれ下記となります。
 *** IP アドレス	: 192.168.0.1
 *** ネットマスク	: 255.255.255.240
 *** ネットワーク	: 192.168.0.0
 *** ブロードキャスト: 192.168.0.15
 *** アドレスの数	: 16 個


## 経路の確認

LANとLANをつなげる場合、もしくはLANとWANをつなげる場合は、ゲートウェイ（ルーター）が間に接続されています。
ゲートウェイは次の図の様にネットワークのデータを接続された隣のネットワークへ転送します。

//indepimage[linuxtext2-img12][][latex::width=0.8\maxwidth]


インターネットは多くのネットワークがつながって構成されていて、いくつものネットワークをデータが中継されるので、いくつものゲートウェイを通ってデータが送受信されます。
自分が利用しているコンピュータから通信先のコンピュータまでに仲介する複数のゲートウェイを調べるにはtracerouteコマンドとtracepathコマンドがあります。

書式
traceroute ターゲット
tracepath ターゲット


ターゲットや途中のゲートウェイへデータを送り、ゲートウェイから返答が戻ってくる時間を表示します。


○実習: tracerouteコマンドおよびtracepathコマンドでゲートウェイを確認


tracerouteコマンドで、lpi.jpサーバまでの間にある複数のゲートウェイから返答があるかを確認してください。

# traceroute lpi.jp}
（lpi.jpをトレースルート）
traceroute to lpi.jp (203.174.74.34), 30 hops max, 60 byte packets  
（最大30台までの経由ルータを表示）
 1  172.16.x.x (172.16.x.x)  1.924 ms  1.772 ms  2.136 ms
 2  172.17.x.x (172.17.x.x)  3.447 ms  4.645 ms  5.917 ms            
（略）
14  sv1.lpi.jp (203.174.74.34)  31.723 ms  30.773 ms  30.823 ms      

# tracepath lpi.jp}
（lpi.jpをトレースパス）
 1?: [LOCALHOST]                                         pmtu 1500
 1:  172.16.x.x                                            1.603ms 
 1:  172.16.x.x                                            1.726ms 
 2:  172.17.x.x                                            4.923ms pmtu 1454
（略）
4  sv1.lpi.jp (203.174.74.34)  31.324 ms  30.549 ms  30.621 ms      
     Resume: pmtu 1454 hops 4 back 4 


172.16.x.xまで2.136 m秒、172.17.x.xまで5.917 m秒、sv1.lpi.jpまで30.823 m秒かかっていることがわかります。
ゲートウェイによってはセキュリティ対策のため、コマンドに応答しない場合があります。

## ネットワークの設定

CentOS 7では、システム起動の推奨技術が SysV init から systemd 変わり、また、NetworkManager サービスを推奨するようになったため、ネットワークの設定ファイルやコマンドも変わりました。

ここでは、CentOS 7で推奨される技術について説明し、章末にCentOS 7 と CentOS 6の比較表を掲載します。

### ネットワークインターフェース

ネットワークへアクセスするためにネットワークインターフェースが必要です。
物理的なネットワークインターフェースとしてネットワークインターフェースカード(NIC)があります。現在は、多くの場合、ネットワークインターフェースがコントロールチップの中に統合されています。
プログラムが内部的に使う仮想のネットワークインターフェースとしてループバックインターフェースがあります。

### IPアドレスを確認

IPアドレスの確認は、ipコマンドの他、NetworkManager の nmcli, nmtui コマンドでも行えます。また、従来からのifconfigコマンドでも確認できます。

書式
ip a[ddress] [インターフェース]
ネットワークインターフェースに設定されたIPアドレスとサブネットマスクを表示します。

nmcli [インターフェース]
コマンドラインでネットワークの設定ができるインターフェイスです。オプション無しで実行すると、現在の設定を表示します。

nmtui
会話型でネットワークの設定ができるインターフェイスです。


インターフェース(loやenp0s3など)を省略すると、全インターフェース情報を表示します。


○実習: ネットワークインターフェースのIPアドレスを確認


ip address コマンドを使ってホストのIPアドレスを確認してみましょう。

$ ip a}
（ネットワークインターフェースの情報を表示）

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 08:00:27:1c:d0:16 brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.16/24 brd 192.168.100.255 scope global dynamic enp0s3
       valid_lft 258878sec preferred_lft 258878sec
    inet6 fe80::a23f:e597:2d02:2236/64 scope link 
       valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN qlen 1000
    link/ether 52:54:00:ae:ff:74 brd ff:ff:ff:ff:ff:ff
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
4: virbr0-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen 1000
    link/ether 52:54:00:ae:ff:74 brd ff:ff:ff:ff:ff:ff


ipコマンドで表示されたloがループバックインターフェース(機器が正常に稼動しているか確認するためにデータを送って試すループバックテストなどに利用)で、enp0s3が物理的に存在するEthernet(イーサネット）のネットワークインターフェースです。


$ nmcli device}
（ネットワークインターフェースの情報を表示）

デバイス    タイプ    状態      接続   
virbr0      bridge    接続済み  virbr0 
enp0s3      ethernet  接続済み  enp0s3 
lo          loopback  管理無し  --     
virbr0-nic  tun       管理無し  --   


### IPアドレスの設定ファイル

RedHat Linux系のディストリビューションはIPアドレスの設定を2つの設定ファイルに記述しておき、ブート時にはそれらの設定ファイルにより設定されます。
/etc/sysconfig/network-scripts/ifcfg-XXX設定ファイルはXXXインターフェースのIPアドレスとサブネットマスクなどを記述します。
XXXはループバックインターフェースの場合はlo、ネットワークインターフェースカードの場合はenX0Y,enX1Y…とデバイスの種類とスロット位置により番号が振られます。


/etc/sysconfig/network-scripts/ifcfg-XXX設定ファイルの主な内容は次の様になります。

//tsize[40,60]
//table[tbl18][ifcfg設定ファイルの項目]{
項目	内容	
---------------------------------------------------------------------------
ONBOOT	起動時にアドレスを自動設定する（yes）か設定しない（no）
DEVICE	ネットワークインターフェイス
HWADDR	MACアドレス


BOOTPROTO以降の設定を利用(static)か自動取得(dhcp)

//tsize[40,60]
//table[tbl19][固定アドレス（static）を設定する場合の設定項目]{
項目	内容	
---------------------------------------------------------------------------
IPADDR	IPアドレス
NETMASK	サブネットマスク
NETWORK	ネットワーク


起動時にアドレスを自動設定するにはDHCP機能が提供された環境が必要です。
/etc/sysconfig/network設定ファイルはデータが他のネットワークへ転送されるゲートウェイのアドレスとホスト名を記述します。
/etc/sysconfig/network設定ファイルの主な内容は次の様になります。

//tsize[40,60]
//table[tbl20][ネットワークの項目]{
項目	内容	
---------------------------------------------------------------------------
NETWORKING	ネットワークを有効にする（yes）か無効にする（no）
HOSTNAME	ホスト名
GATEWAY	ゲートウェイアドレス



○実習: ネットワークインターフェースの確認


catコマンドでファイルを表示してみます。

$ cat /etc/sysconfig/network-scripts/ifcfg-lo}
（設定ファイルを表示）
DEVICE=lo
IPADDR=127.0.0.1	（IPアドレス）
NETMASK=255.0.0.0	（サブネットマスク）
NETWORK=127.0.0.0	（ネットワーク）
# If you're having problems with gated making 127.0.0.0/8 a martian,
# you can change this to something else (255.255.255.255, for example)
BROADCAST=127.255.255.255
ONBOOT=yes		（ブート時に有効にする）
NAME=loopback		（インターフェース名）

$ cat /etc/sysconfig/network-scripts/ifcfg-enp0s3}
（設定ファイルを表示）
TYPE=Ethernet
BOOTPROTO=dhcp		(DHCP)
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=enp0s3
UUID=81f923e2-8569-4d4d-b650-37bef00fac0b
DEVICE=enp0s3
ONBOOT=no
PEERDNS=yes
PEERROUTES=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes
IPV6_PRIVACY=no


MACアドレスはハードウェアに設定されているユニークな番号であり、正しいMACアドレスが設定されていない場合通信することができなくなるため、自動的に認識された番号を書き換えないようにしましょう。ブロードキャストは1対多で通信をする場合に使われるアドレスで、ホスト部のビットが全部１のアドレスです。

### インターフェースの設定

ネットワークのインターフェースは設定ファイルを書き換えて、systemctlコマンドにrestartオプションを付けて再起動することで変更できます。


○実習: ネットワークインターフェースの再設定


ip addr コマンドで設定を確認後、IPアドレスを変更してNetworkManagerとnetworkサービスを再起動してみましょう。
NetworkManagerとnetworkサービスを再起動したあとは、ip addrコマンドでIPアドレスの変更が適用されているか確認してください。

# ip addr show dev enp0s3}
（enp0s3の設定を表示）
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0C:29:FB:5F:23 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.60/24 brd 192.168.1.255 scope global dynamic enp0s3
       valid_lft 256662sec preferred_lft 256662sec
    inet6 fe80::20c:29ff:fefb:5f23/64 scope link 
       valid_lft forever preferred_lft forever

# vi /etc/sysconfig/network-scripts/ifcfg-enp0s3}       
（IPアドレスを変更）
CentOS 7で推奨されているsystemd の systemctl コマンドを使用します。
# systemctl restart network.service}
（ネットワークサービスの再起動）


# ip addr show dev enp0s3}
（enp0s3の設定を表示）
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.70  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::b8cf:2183:97a8:f43b  prefixlen 64  scopeid 0x20<link>
        ether   txqueuelen 1000  (Ethernet)
        RX packets 17091  bytes 1826635 (1.7 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2206  bytes 555482 (542.4 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 08:00:27:86:94:00 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.70/24 brd 192.168.1.255 scope global dynamic enp0s3
       valid_lft 256662sec preferred_lft 256662sec
    inet6 fe80::b8cf:2183:97a8:f43b/64 scope link 
       valid_lft forever preferred_lft forever


## ルーティング

ネットワークの状況を表示するためのip routeコマンドやssコマンドがあり、これらのコマンドでデータが流れる方向(ルーティング)を調べられます。

書式
ip route [オプション]
ss [オプション]

ネットワークの状況を表示します。

//emlist[ssのオプション]{
-V
バージョン情報
-a
全てのソケットを表示
-n
サービス名に変換せずに表示
-r
ホスト名を名前解決
-p
ソケットを使用しているプロセスIDを表示
-s
集約したソケット情報
-4
IPv4のソケットのみ表示. 他のオプションと併用.
-6
IPv6のソケットのみ表示. 他のオプションと併用.
-t
TCPのソケットのみ表示
-u
UDPのソケットのみ表示
-e
詳細なソケット情報を表示

○実習: ルーティングとインターフェースの確認

ip route コマンドを利用しルーティングテーブルを表示してみましょう。

$ ip route}
（ルーティングを表示）
default via 192.168.1.1 dev enp0s3  proto static  metric 100 
192.168.1.0/24 dev enp0s3  proto kernel  scope link  src 192.168.1.70  metric 100 
192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1 

結果は、全てのデータは192.168.1.1へ行くので、192.168.1.1がゲートウェイであれば、ネットワークの外へデータが転送されます。

### ルーティングの変更

ルーティングの変更を行なうには、ip routeコマンドを使用します。ip routeコマンドの実行には、管理者権限が必要です。


書式
ip [オプション] r[oute] {コマンド|help}
または
route (非推奨）

書式
ip route {add|del} ターゲット/サブネット via ゲートウェイアドレス dev インタフェース

書式
route add [-net|-host] ターゲット [netmask サブネットマスク] [インタフェース]


routeコマンドでは、addを指定するとルーティングに経路を追加します。ターゲットには、-netを指定した場合にはネットワークアドレスを、-hostを指定した場合にはホストアドレスを宛先として設定します。サブネットマスクの指定を省略した場合は、ターゲットに設定したアドレスから判別されたクラスに該当するマスク値が設定されます。インタフェースを省略すると、カーネルが自動的に最適なデバイスを設定します。

ip route コマンドでは routeコマンドと違って -net, -host を指定できません。代わりにCIDR表記で指定します。ターゲット/32だと-hostと同様にホストを指定でき、ターゲット/xx(32 以外) だと-netと同様にネットワークを指定できます。

○実習: ルーティングの追加


クラスCのネットワーク192.168.2.0への経路を追加してみます。

# ip route add 192.168.2.0/24 via 192.168.1.1 dev enp0s3}
（経路を追加）
# ip route}
（ルーティングを表示）
default via 192.168.1.1 dev enp0s3  proto static  metric 100 
192.168.2.0/24 via 192.168.1.1 dev enp0s3 
192.168.1.0/24 dev enp0s3  proto kernel  scope link  src 192.168.1.70  metric 100 



書式
ip route del ターゲット/サブネット via ゲートウェイアドレス

delを指定すると、ルーティングから経路を削除します。


○実習: ルーティングの削除


クラスCのネットワーク192.168.2.0への経路を削除してみます。

# ip route del 192.168.2.0/24 via 192.168.1.1}
（経路を削除）
# ip route}
（ルーティングを表示）
default via 192.168.1.1 dev enp0s3  proto static  metric 100 
192.168.1.0/24 dev enp0s3  proto kernel  scope link  src 192.168.1.70  metric 100 
192.168.122.0/24 dev virbr0  proto kernel  scope link  src 192.168.122.1 


## DNSを使う設定

名前解決の機能を使うには/etc/nsswitch.confファイルで何を使うか指定します。
ファイルを使う指定があれば/etc/hostsファイルを参照し、DNS(Domain Name System：ドメイン・ネーム・システム)を使う指定があれば、/etc/resolv.confファイルを見てDNSサーバを使います。
/etc/nsswitch.confファイルではhosts:の項目でファイル(files)やDNS(dns)を指定します。hosts:の項目のファイルやDNSの優先順位は記述された順番となります。
hosts:      files dns


/etc/resolv.confファイルにはnameserverでDNSサーバのアドレスが登録されています。
デフォルトでは、このファイルは NetworkManager 経由で管理されます。

# cat /etc/resolve.conf
# Generated by NetworkManager
nameserver 192.168.1.1


nmcliコマンドでDNSサーバーの設定を確認してみましょう。

# nmcli d show enp0s3}
GENERAL.デバイス:                       enp0s3
GENERAL.タイプ:                         ethernet
GENERAL.ハードウェアアドレス:           08:00:27:1C:D0:16
GENERAL.MTU:                            1500
GENERAL.状態:                           100 (接続済み)
GENERAL.接続:                           enp0s3
GENERAL.CON パス:                       /org/freedesktop/NetworkManager/ActiveConnection/4
WIRED-PROPERTIES.キャリア:              オン
IP4.アドレス[1]:                        192.168.1.70/24
IP4.ゲートウェイ:                       192.168.1.1
IP4.DNS[1]:                             192.168.1.1
IP6.アドレス[1]:                        fe80::a23f:e597:2d02:2236/64
IP6.ゲートウェイ: 

実際に設定されているDNSサーバーで名前解決してみましょう。

# nslookup lpi.jp}
Server:		192.168.1.1
Address:	192.168.1.1#53

Non-authoritative answer:
Name:	lpi.jp
Address: 203.174.74.34


/etc/hostsファイルはホストの名前とIPアドレスの関係を静的に定義しておくファイルです。定義は次のように1行で1つの定義を書きます。

IPアドレス	名前(FQDN)	ホスト名
例
127.0.0.1               localhost.localdomain	localhost
192.168.1.50		test.lpi.or.jp		test

/etc/resolve.conf で files dns の順になっているので、
/etc/hostsファイルはDNSサーバーによる名前解決よりも優先されます。




### 名前(FQDN)

インターネットではIPアドレスだけを使うと人間にはわかり辛いので、FQDN(Fully Qualified Domain Name)と呼ばれる名前(例：www.lpi.or.jp)を使えます。IPアドレスと名前の対応はdigコマンドやnslookupコマンドで調べられます。

書式
nslookup ターゲット
ターゲットの名前とIPアドレスを返します。


○実習: IPアドレスに対応するホスト名の問い合わせ


nslookup コマンドを利用して DNS へホスト名の問い合わせを行なってみましょう

$ nslookup 203.174.74.34}
（203.174.74.34のホスト名の問い合わせ）
Server:         192.168.1.1
Address:        192.168.1.1#53
Non-authoritative answer:
34.74.174.203.in-addr.arpa	name = sv1.lpi.jp.
（IPアドレスに対してFQDN）
Authoritative answers can be found from:
（略）

$ nslookup lpi.jp}
（lpi.jpのIPアドレス問い合わせ）
Server:         192.168.1.1
Address:        192.168.1.1#53
Non-authoritative answer:
Name:    lpi.jp
Address: 203.174.74.34


## ポート番号

TCP/IPで通信をする場合は、IPアドレスに加えてサービスごとにポート番号を使います。
ポート番号がどのサービスに対応するかは規格として取り決められており、一般的なサービスはサービス番号との対応が/etc/servicesファイルに書かれています。

//tsize[50,40,40]
//table[tbl21][ポート番号と対応サービス]{
項目	ポート番号範囲	内容
---------------------------------------------------------------------------
WELL KNOWN PORT NUMBERS	0～1023	一般的なポート番号
REGISTERED PORT NUMBERS	1024～49151	登録済みポート番号
DYNAMIC AND/OR PRIVATE PORTS	49152～65535	自由に利用できるポート番号


//tsize[30,50]
//table[tbl22][サーバで使われる主なポート番号と対応するサービス]{
ポート番号	サービス名	
---------------------------------------------------------------------------
20	FTP（データ）
21	FTP（制御）
22	SSH
23	Telnet
25	SMTP
53	DNS
80	HTTP
443	HTTPS



## サービスの確認

サーバではホームページを見せるなどのサービスを提供するプログラムを主に動かします。
Linuxのサービスやネットワークの状況を表示するssコマンドは、提供されているサービスを調べて表示することができます。


○実習: 提供されているTCPサービスの表示


ssコマンドに-aオプションと-tオプションを付けて実行してください。

$ ss -at}
（TCPサービス一覧を表示）
State      Recv-Q Send-Q Local Address:Port                 Peer Address:Port                
LISTEN     0      128        *:sunrpc                   *:*                    
LISTEN     0      5      192.168.122.1:domain                   *:*                    
LISTEN     0      128        *:ssh                      *:*                    
LISTEN     0      128    127.0.0.1:ipp                      *:*                    
LISTEN     0      100    127.0.0.1:smtp                     *:*                    
ESTAB      0      0      192.168.100.16:ssh                  192.168.100.2:53767                
ESTAB      0      0      192.168.100.16:ssh                  192.168.100.2:55528                
LISTEN     0      128       :::sunrpc                  :::*                    
LISTEN     0      128       :::ssh                     :::*                    
LISTEN     0      128      ::1:ipp                     :::*                    
LISTEN     0      100      ::1:smtp                    :::*  



○実習: 提供されているUDPサービスの表示


netstatコマンドに-aオプションと-uオプションを付けて実行してください。

$ ss -au}
（UDPサービス一覧を表示）
State      Recv-Q Send-Q Local Address:Port                 Peer Address:Port                
UNCONN     0      0          *:36052                    *:*                    
UNCONN     0      0          *:mdns                     *:*                    
UNCONN     0      0      127.0.0.1:323                      *:*                    
UNCONN     0      0      192.168.122.1:domain                   *:*                    
UNCONN     0      0      * %virbr0:bootps                   *:*                    
UNCONN     0      0          *:bootpc                   *:*                    
UNCONN     0      0          *:47179                    *:*                    
UNCONN     0      0        ::1:323                     :::*                    
UNCONN     0      0         :::43455                   :::*      


## ネットワークセキュリティの設定

ネットワークセキュリティのためにTCPラッパー(TCP Wrapper)という機能が提供されています。TCPラッパーでセキュリティを強化する場合は、サービスがTCPラッパー機能を提供するライブラリ(プログラム)を利用している必要があります。アクセスを制限する/etc/hosts.denyファイルとアクセスを許可する/etc/hosts.allowファイルを用意する必要があります。
2つの制御ファイルはサービスを提供するプログラムのリストに対してコロン(:)で区切り、適応するネットワークやIPアドレスやホスト名やドメイン名などのクライアントのリストを書き、ファイルによって許可または拒否します。クライアントのリストの後には:で区切り、制限に引っかかる場合に実行するシェルスクリプトを書けます。全てを表す時はリストの代わりにALLと記述します。制御ファイルは次のように記述します。

###[column] プログラムのリスト : クライアントのリスト@<tt>{[ : シェルスクリプト]}
例

/etc/hosts.allow

sshd : 192.168.1.60

/etc/hosts.deny

ALL : ALL

2つのファイルに制御を記述して初めて設定が有効になります。
/etc/hosts.denyファイルで全てのアクセスを不可にしてから、/etc/hosts.allowファイルで必要なサービスを解放すると、安全な設定になるでしょう。

###[/column]



### ファイアウォール(firewalld)の設定

CentOS 7では、iptablesに代わり、firewalldが推奨されています。iptablesも使用できますが、使用するにはfirewalldを無効にする必要があります。
本節では、まずfirewalldの操作を学習し、その後、iptablesに切り替えてみましょう。


firewalldでは、ゾーンと呼ばれる単位ごとに設定が可能です。ここではデフォルトのゾーンに対して操作します。


firewalld の状態は、firewall-cmdコマンドまたはsystemctlコマンドで確認できます。

# firewall-cmd --state}
（ファイアウォールの状態を表示）
running

systemctl でfirewalldの状態と設定を確認してみましょう。
# systemctl status firewalld.service}
（ファイアウォールの設定を表示します。activeつまり実行中であることと、enabledであることがわかります。）
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)
   Active: active (running) since 水 2017-03-01 12:18:30 JST; 6h ago
     Docs: man:firewalld(1)
 Main PID: 732 (firewalld)
   CGroup: /system.slice/firewalld.service
           └─732 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid

 3月 01 12:18:28 localhost.localdomain systemd[1]: Starting firewalld - dyna...
 3月 01 12:18:30 localhost.localdomain systemd[1]: Started firewalld - dynam...
Hint: Some lines were ellipsized, use -l to show in full.


次に、firewalldの設定を確認してみましょう。このコマンドはrootまたはsudoで実行してください。
# firewall-cmd --list-all}
（ファイアウォールの設定を表示）
public (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3
  sources: 
  services: dhcpv6-client ssh
  ports: 
  protocols: 
  masquerade: no
  forward-ports: 
  sourceports: 
  icmp-blocks: 
  rich rules: 


書式
firewall-cmd [オプション...]

オプション
--permanent
永続的設定に使用します。
このオプションを使用しない場合、実行中のfirewalldに対して処理されます。
このオプションを付けて実行した設定を有効にするには、--reload オプションを使用するか、firewalldの再起動が必要です。

--list-all
追加、有効化されている項目をすべて表示します。

--list-services
追加、有効化されているサービスを表示します。

--add-services サービス
サービスを有効にします。

--remove-services サービス
サービス無効にします。

--reload
permanent設定を再読み込みします。




○実習: ファイアウォールの表示


現在有効になっているサービスのみ確認してみましょう。
# firewall-cmd --list-services}
（現在有効なサービスを表示）
dhcpv6-client ssh


ディストリビューションによってはデフォルトではほとんどのサービスが抑制されており、サービスを使用するために設定を追加する必要があります。

サービスの追加はfirewall-cmdコマンドで可能です。firewall-cmdでの設定には、firewalldが起動中のみ有効な一時的な設定とリブートしても設定が消えない永続的な設定が可能です。構築中の環境では、まず一時的に設定し、動作を確認した後、permanentオプションで永続的な設定をしても良いでしょう。


○実習: ファイアウォールの設定変更

ファイアウォールに Apacheサービスのhttpを一時的に、https を永続的に追加してみます。

# firewall-cmd --add-service=http
(httpを一時的に設定)
success
# firewall-cmd --add-service=https --permanent
(httpsを永続的に設定)
success
httpとhttpsがそれぞれ追加されていることを確認してみましょう。

# firewall-cmd --list-services
(--permanentをつけないと、httpは表示されますが、httpsは表示されません。つまり、今現在 httpは無効です。)
dhcpv6-client http ssh
# firewall-cmd --list-services --permanent   
(--permanentをつけると、httpsは表示されますが、httpは表示されません。つまり、再起動すると http は無効になります。)
dhcpv6-client https ssh


httpsがシステム起動時に設定されることを確認するため、firewalldを再起動します。

# systemctl restart firewalld.service}


再起動の前後でどのように変わったかを確認してみましょう。

# firewall-cmd --list-services
（再起動前にpermanentで設定したhttpが、再起動後に有効になっています。）
dhcpv6-client https ssh
# firewall-cmd --list-services --permanent
dhcpv6-client https ssh


### iptables への切り替え

次に、ファイアウォールをfirewalldからiptablesに切り替えて動作を確認しましょう。

大まかな手順は、下記の通りです。

 * firewalld の無効化
 * iptables の有効化
 * iptables の設定

### まず、firewalld を無効化します。
(firewalld を停止します。)
# systemctl stop firewalld.service
(firewalld を無効化します。無効化には disable または mask を指定します。)
# systemctl disable firewalld.service
Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.
Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.
(mask を指定すると、systemd からfirewalld アクセスできないようにできます。)
# systemctl mask firewalld.service
Created symlink from /etc/systemd/system/firewalld.service to /dev/null.
# systemctl status firewalld.service
● firewalld.service
   Loaded: masked (/dev/null; bad)
   Active: inactive (dead)

 3月 11 07:05:18 localhost.localdomain firewalld[14853]: WARNING: COMMAND_FAILED: '/usr/sbin/iptable...d:
 3月 11 07:05:18 localhost.localdomain firewalld[14853]: WARNING: COMMAND_FAILED: '/usr/sbin/iptable...d:
: : : 


### 次に、iptables を有効化します。
(iptables-servicesをインストールします。)
# yum -y install iptables-services
: : :
(iptblesサービスを起動します。)
# systemctl start iptables.service
(iptblesサービスを有効化します。)
# systemctl enable iptables.service
Created symlink from /etc/systemd/system/basic.target.wants/iptables.service to /usr/lib/systemd/system/iptables.service.
(iptblesサービスを状態を確認します。)
# stemctl status iptables.service
● iptables.service - IPv4 firewall with iptables
   Loaded: loaded (/usr/lib/systemd/system/iptables.service; enabled; vendor preset: disabled)
   Active: active (exited) since 土 2017-03-11 07:35:31 JST; 34s ago
 Main PID: 15829 (code=exited, status=0/SUCCESS)
: : :
#

iptables コマンドに-Lオプションをつけて、現在の設定を確認します。

# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source        destination         
ACCEPT     all  --  anywhere      anywhere       state RELATED,ESTABLISHED
ACCEPT     icmp --  anywhere      anywhere            
ACCEPT     all  --  anywhere      anywhere            
ACCEPT     tcp  --  anywhere      anywhere       state NEW tcp dpt:ssh
REJECT     all  --  anywhere      anywhere       reject-with icmp-host-prohibited

Chain FORWARD (policy ACCEPT)
target     prot opt source        destination         
REJECT     all  --  anywhere      anywhere       reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT)
target     prot opt source        destination    


エディタで設定ファイルに、Apacheのhttp(ポート番号:80)とhttps(ポート番号:443)を追加します。
# vi /etc/sysconfig/iptables

# sample configuration for iptables service
# you can edit this manually or use system-config-firewall
# please do not ask us to add additional ports/services to this default configuration
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT  # この行を追加
-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT # この行を追加
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT


iptablesサービスを再起動して、追加した設定を有効にします。
# systemctl restart iptables.service

http(80)とhttps(443)が追加されたことを確認します。
# iptables -L
Chain INPUT (policy ACCEPT)
target   prot opt source     destination         
ACCEPT   all  --  anywhere   anywhere     state RELATED,ESTABLISHED
ACCEPT   icmp --  anywhere   anywhere            
ACCEPT   all  --  anywhere   anywhere            
ACCEPT   tcp  --  anywhere   anywhere     state NEW tcp dpt:ssh
ACCEPT   tcp  --  anywhere   anywhere     state NEW tcp dpt:http  # 追加されました。
ACCEPT   tcp  --  anywhere   anywhere     state NEW tcp dpt:https # 追加されました。
REJECT   all  --  anywhere   anywhere     reject-with icmp-host-prohibited

Chain FORWARD (policy ACCEPT)
target   prot opt source     destination         
REJECT   all  --  anywhere   anywhere     reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT)
target   prot opt source     destination  






## CentOS 7とCentOS 6の比較

CentOS 7では、CentOS 6とシステム起動の技術が変更になりました。またネットワーク関連のコマンドについて新しいコマンドを推奨しています。
この節では、CentOS 7 と CentOS 6 の違いについてネットワークに関連する箇所を比較表で紹介します。


//tsize[50,50,55]
//table[tbl23][コマンド比較]{
CentOS 7(推奨)	CentOS 6	機能
---------------------------------------------------------------------------
systemd	SysV init	システム起動の技術
iproute(ip, ss etc.)	net-tools(ifconfig, netstat etc.)	パッケージ名
ip a[ddress] [デバイス]	ifconfig [デバイス]	インターフェイスの設定、確認
nmcli, nmtui	なし	NetworkManager のインターフェイス
ss -a	netstat -a	ソケットの確認
ip r[oute]	route	ルーティングの設定確認
ip route add default via アドレス dev デバイス	route add default gw アドレス	ルーティングの設定
ip r[oute]	netstat -nr	ネットワーク状況の表示
ip n[eigh]	arp -a	arpテーブルの確認
firewalld	iptables	ファイアウォール技術
firewalld	iptables-service	firewallのパッケージ名
firewall-cmd --add-service=サービス	iptables -A チェーン ルール詳細	ルールの一時的追加
firewall-cmd --remove-service=サービス	iptables -D チェーン ルール詳細	ルールの一時的削除
firewall-cmd [オプション] --permanent	/etc/sysconfig/iptablesの編集と再起動	ルールの永続的追加削除
systemctl start サービス.service 	service start サービス	サービスの起動
systemctl stop サービス.service 	service stop サービス	サービスの停止
systemctl enable サービス.service	chkconfig サービス on	サービスの自動起動設定
systemctl disable サービス.service	chkconfig サービス off	サービスの自動起動解除



