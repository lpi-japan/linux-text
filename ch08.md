= シェルスクリプト

シェルにより入力するコマンドは、シェルスクリプトにより順次実行可能な形式になります。それを応用することにより、コマンド入力による作業を自動化することが可能です。その際に必要な技術である、シェルスクリプトを学習しましょう。

###[column] この章の内容

9.1 シェルとシェルスクリプト

9.2 プログラミング

9.2.1 プログラムの例

9.2.2 プログラムの要素

9.3 シェルスクリプトの作成

9.3.1 シェルスクリプトの作成

9.3.2 変数

9.3.3 echoコマンド

9.3.4 readコマンド

9.3.5 シェル変数

9.3.6 環境変数

9.3.7 コメント

9.3.8 引用符

9.3.9 引数

9.3.10 shift文

9.3.11 エスケープシーケンス

9.3.12 sourceコマンド

9.3.13 バックスラッシュ\

9.4 条件分岐

9.4.1 if文

9.4.2 ファイルの属性比較

9.4.3 複数の条件を重ねる

9.4.4 一対多の条件分岐

9.5 繰り返し

9.5.1 for文

9.5.2 while/until文

9.5.3 select文

9.5.4 繰り返しの制御

9.6 サブルーチン

9.6.1 関数

9.6.2 return文

9.7 実際のシェルスクリプト

9.7.1 起動スクリプト

9.7.2 関数のシェルスクリプト

9.8 デバッグ

9.8.1 bashコマンド

9.9 章末テスト

###[/column]



## シェルとシェルスクリプト

シェルのプログラミングを始める前に、シェルとシェルスクリプトについて学習しましょう。


### シェル

第1章でカーネルはOSの基本部分であり、ハードウェアを操作するほかさまざまな機能を司っていると説明しました。

シェルとは、貝殻(=Shell)という意味です。カーネルが提供する機能を操作する際に、OSと対話的に操作する必要があります。シェルはOSの、特にカーネル部分を包み込んでいることからその名があり、対話機能を提供するものです。
シェルはコマンドの入力を受け付けそのコマンドを実行し、入力したユーザに対しその結果を返す役割があります。

### シェルスクリプト

/etcディレクトリと/homeディレクトリを圧縮して外部サーバーにコピーするといった流れを考えてみましょう。
実際に実行するコマンドを列挙するとたとえば以下のような方法が考えられます。

# tar cvzf 120626-etc.tar.gz /etc
# tar cvzf 120626-home.tar.gz /home
# scp 120626-etc.tar.gz root@backup.local.example.com:~/backup
# scp 120626-home.tar.gz root@backup.local.example.com:~/backup


これを実行のたびに入力するのは面倒です。さらに1つのコマンドの処理が終わるまで次のコマンドを実行できないため効率がよくありませんし、そもそも実行する際に端末の前に人手が必要です。

このような繰り返し行なう処理を自動化するための手段としてシェルスクリプトを書いて実行させる方法があります。

先ほどの一連処理をsystem-backup.shという名前のファイルを作成して書き込み、system-backup.shを実行することでファイルに書き込んだコマンドを順に実行します。

#!/bin/bash

tar cvzf 120626-etc.tar.gz /etc
tar cvzf 120626-home.tar.gz /home
scp 120626-etc.tar.gz root@backup.local.example.com:~/backup
scp 120626-home.tar.gz root@backup.local.example.com:~/backup


## プログラミング

コンピュータに対して、指示を与え順番に実行させる機能を、プログラムといいます。そのプログラムを作成することをプログラミングといいます。
今まで学習したコマンドを、条件分岐や繰り返しなど制御機能を加え実行することができます。これをシェルスクリプトといいます。

### プログラムの例

プログラムという言葉を聞いて、最初に思いつくのは、運動会や演劇会のプログラムかもしれません。また、新聞に掲載されているテレビの番組表もプログラムです。何かが順序立てて進むものを、プログラムといいます。
では、実際にプログラムを作成するとなると、どのような例があるでしょうか？簡単な例だと、テレビ番組の録画予約があります。開始時刻から終了時刻とチャンネルを指定し、画質を指定したりもします。少し複雑な例ですと、エアコンの設定で「**度に達したら冷房を入れて、**度を下回ったら冷房を止める」などの条件を設定するというのも、一種のプログラムです。

### プログラムの要素

プログラミングには、どの種類のプログラムでもいくつかの重要な構成要素があります。プログラムの要素は主に以下の4つです。

 * 順次実行
 * 条件分岐
 * 繰り返し
 * サブルーチン
これらをしっかりマスターしてください。

## シェルスクリプト

それでは実際にシェルスクリプトを作成してみましょう。ここではシェルスクリプトを作成して実行する手順を紹介します。

### シェルスクリプトの作成

シェルスクリプトは、テキストで記述します。vi等のテキストエディタを利用してください。lsdate.shというファイルに、lsとdateコマンドを実行するシェルスクリプトを記述してみましょう。

$ vi lsdate.sh}
（lsdate.shというファイルを作ります）


vi上で以下のようなスクリプトを記述して、保存終了してください。

#!/bin/bash
ls
date



### シェルの指定

1行目に#!/bin/bashと記述しました。ファイルの1行目には、利用するシェルの種類とそのコマンド位置を記述します。
シェルには数種類ありますが、今回はbashを使用します。

1行目に利用するシェルを指定、2行目以降に実行するコマンドを1行ずつ入力していきます。


### パーミッションの変更

作成したシェルスクリプトを実行するには、パーミッションを変更してファイルの実行権限をつける必要があります。例のようにシェルスクリプトに実行権限がついているか確認してみましょう。

lsコマンドでファイルのアクセス権限を確認します。


$ ls -l lsdate.sh}
-rw-rw-r--. 1 tooyama tooyama      21 Jun 6  09:51  lsdate.sh


実行権限を付与するためにchmodコマンドを使います。

$ chmod u+x lsdate.sh}
$ ls -l lsdate.sh}
-rwxrw-r--. 1 tooyama tooyama      21 Jun 6  09:51  lsdate.sh


これで所有者に実行権限が与えられました。
実行権限をシェルスクリプトにつけたら早速実行してみましょう。

$ ./lsdate.sh}
Desktop	diff2		ls-l-output		ls-usr-bin	touched-file
cat-output	hosts.bak	ls-l-output-second	lsdate.sh	uniq-sample
diff1		hosts.new2	ls-output		score		（lsの実行結果）
Fri  Jun  6  09:55:05 JST 2008		　       （dateの実行結果）


./というのはパス指定です。意味は「カレントディレクトリにある(lsdate.sh を実行せよ)」ということです。lsやcpを実行するときは、パスが通っているので、このようなパス指定は必要ありません。今回は、カレントディレクトリにある特定のシェルスクリプトを実行させるために、パス指定しました。
lsdate.sh の中に記述された、lsコマンドとdateコマンドが順に実行されたことがわかります。


### コメント

コメントとは、プログラム上に書く注釈のことです。シェルの場合は#で始まる行がコメントとして認識され、プログラムの実行時はコメントは無視されます。
コメントは多くの場合、プログラマーが記述したプログラムがどういった処理をするのかを記述したり、一時的に特定の処理を無効化（コメントアウト）する場合に利用します。


○実習: コメントがあるスクリプトの実行

先ほど作成したlsdate.shを編集して、dateコマンドをコメントアウトします。

$ vi lsdate.sh}
#!/bin/bash
ls
#date


### シェルスクリプトを実行

$ ./lsdate.sh}
Desktop	diff2		ls-l-output		ls-usr-bin	touched-file
cat-output	hosts.bak	ls-l-output-second	lsdate.sh	uniq-sample
diff1		hosts.new2	ls-output		score		（lsの実行結果）
dateコマンドの出力がなくなったのがわかります。


### echoコマンド

echoコマンドは引数で与えた文字列を標準出力に出力するコマンドです。

書式
echo [オプション] 文字列


オプション
-n 
改行を抑制します。通常の出力は改行されますが、このオプションがあると改行されません。


$ echo Message test}
Message test
（echoコマンドで指定された文字列を表示する）



### 変数

プログラミングをする上で、非常に重要な考え方が、変数です。変数は、簡単に言うと「ハコ」で、中に数値や文字列が入ります。ちょうど、中学生の数学のときに習ったxやyがそれにあたります。シェルスクリプトプログラミングでは、変数に数値や文字列を代入し、それを利用することができます。
 変数の代入は「=」を使って行ない、参照は「$」をつけて行います。


○実習: シェル変数の作成


シェル関数 abc に値を設定し、echoコマンドで内容を確認してみましょう。

$ abc=123}
$ echo $abc}
123
（abcの内容を表示する）


変数abcに123を代入しました。
bashでは、一次元の配列変数を使用することができます。要素は角括弧@<tt>{[]}で囲みます。配列変数の内容を表示する場合は、$の後ろに波括弧{}で配列変数を囲みます。

$ abc[0]=123}
$ abc[1]=456}
$ echo ${abc[0]}}
123
（abc[0]の内容を表示する）
$ index=1}
$ echo ${abc[$index]}}
456
（abc[1]の内容を変数を使って表示する）


### シェル変数と環境変数

シェルには、2種類の変数があります。シェル変数と環境変数です。シェル変数は、実行しているシェルの内部でのみ有効です。環境変数は、そこから実行されたコマンド内でも有効になります。
環境変数は、シェル変数から作成できます。


○実習: 環境変数の作成


exportコマンドを使って、環境変数を作成してみましょう。

$ export abc}
（シェル変数abcを環境変数abcにする）
$ export xyz=234}
（環境変数xyzを作成し234を代入する）


一つ目のコマンドではabcという環境変数を作成しています。abcには値を代入していません。
二つ目のコマンドではxyzという環境変数を作成しています。xyzには234を代入しています。

次に、2つのスクリプトBBB.shとCCC.shを使って、シェル変数と環境変数の動作の違いについて確認してみましょう。

$ cat BBB.sh}
#!/bin/bash
xxx=123                     # シェル変数xxxに123を代入する
export yyy=234              # 環境変数yyyに234を代入する
echo xxx=$xxx in BBB.sh     # 変数xxxの値を表示する
echo yyy=$yyy in BBB.sh     # 変数yyyの値を表示する
./CCC.sh                    # CCC.sh を実行する


$ cat CCC.sh}
#!/bin/bash
echo xxx=$xxx in CCC.sh      # 変数xxxの値を表示する
echo yyy=$yyy in CCC.sh      # 変数yyyの値を表示する


$ ./BBB.sh}
xxx=123 in BBB.sh
yyy=234 in BBB.sh
xxx= in CCC.sh
yyy=234 in CCC.sh
$


このシェルスクリプトを実行した時、シェルスクリプトCCC.shの中でxxxの値は
表示されません。シェル変数は引き継がれないからです。一方で、yyyは環境変
数なのでCCC.shまで引き継がれるため、値が表示されます。

### readコマンド

readコマンドは、標準入力からデータを読み込みます。すでに変数にデータが入っていた場合、新しいデータに上書きされます。

書式
read 変数名



○実習: readコマンドの実行


read コマンドを使ってシェル変数の内容を変更してみましょう。

$ echo $abc}
123	
（シェル変数abcの中身が表示されます）
$ read abc}
aaabbbccc
（何か入力します）
$ echo $abc}
aaabbbccc
（シェル変数abcの中身が入れ替わっています）


### シェル変数

シェル変数の一覧を表示する場合は、setコマンドを利用します。また削除する場合は、unsetを利用します。


○実習: シェル変数一覧の表示と削除


シェル変数の一覧表示と削除を行なってみましょう。

$ set}
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:expand_aliases:extquote:force_fignore:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
abc=aaabbbccc
$ set | grep ^abc}
abc=aaabbbccc
（abcで始まるシェル変数のみ確認します）
$ unset abc}
（シェル変数abcを削除します）
$ set | grep ^abc}
$ （abcで始まるシェル変数のみ確認します）


### 環境変数

現在の環境変数の一覧を表示する場合は、envコマンドを利用します。また登録済みの環境変数を削除するときは、unsetコマンドを利用します。


○実習: 環境変数一覧の表示と削除


環境変数の一覧表示・削除を行なってみます。

$ env}
ABC=999999
HOSTNAME=host1.alpha.jp
TERM=xterm
SHELL=/bin/bash
HISTSIZE=1000
（略）
$ env | grep ^ABC}
ABC=999999
（ABCで始まる環境変数のみ確認します）
$ unset ABC}
（環境変数ABCを削除します）
$ env | grep ^abc}
$ （ABCで始まる環境変数のみ確認します）



### 引用符

シェルスクリプトにおいて、文字列を引用符で囲むことができます。利用できる引用符には'(シングルクォート)、"(ダブルクォート)、`(バッククォート)があり、使用される引用符により囲まれた文字列の処理が異なります。
シングルクォートで囲まれた文字列の中に、参照用の「$」付きの変数がある場合、「$」も文字列として認識されるため、変数は展開されません。ダブルクォートの場合、引用符内の「$」付き変数は展開された文字列になります。
バッククォートで囲まれた文字列はコマンドとして解釈され、このとき「$」付きの変数があれば、それを展開した上でコマンドが実行されます。引用符は入れ子が可能です。


○実習: 引用符の動作確認


引用符の違いについて実際に確認してみましょう。

$ ABC=123}
$ echo 'Value of ABC is $ABC.'}
Value of ABC is $ABC.
（$ABCが文字として認識されそのまま表示された）
$ echo "Value of ABC is $ABC."}
Value of ABC is 123.
（$ABCが変数として認識され、内容である123が展開された）
$ XYZ=`date`;}
$ echo "It is $XYZ now."}
It is Thu Mar 20 06:08:14 JST 2017 now.
（$XYZにdateコマンドの実行結果が入っている）
$ echo "It is `date` now."}
It is Thu Mar 20 06:08:14 JST 2017 now.
（ダブルクォートで全体の文字列を囲み、バッククォートで囲んだdateコマンドを挿入して、変数XYZへの代入を省略）


### 引数

シェルスクリプトは、実行時にオプションを引数として参照することができます。引数は$1, $2…など$の後に引数の番号を指定することで参照できます。


○実習: 引数出力の確認


次のように args.sh を作成して、引数呼び出しの動作を確認してみましょう。

$ cat args.sh}
#!/bin/bash

echo '$1:' $1;
echo '$2:' $2;
echo '$3:' $3;
echo '$0:' $0;
echo '$#:' $#;


$ ./args.sh aaa bbb ccc}
$1: aaa
$2: bbb
$3: ccc
$0: ./args.sh
$#: 3
（$1-$3は引数、$0は実行コマンド名、$#は、引数の数を示す）


### shift文

shiftコマンドは、引数の順序をずらします。shiftを実行すると、$2が$1に、$3が$2に・・・になります。


○実習: shiftコマンドの確認


実際にスクリプトを作成して shift コマンドの動作を確認してみましょう。

$ cat argsshift.sh}
#!/bin/bash

echo '$1:' $1;
echo '$2:' $2;
echo '$3:' $3;
shift
echo '$1:' $1;
echo '$2:' $2;


作成したスクリプトに対して、変数を渡してみます。

$ ./argsshift.sh aaa bbb ccc}
$1: aaa
$2: bbb
$3: ccc
$1: bbb
（$1がbbbに変わった）
$2: ccc
（$2がcccに変わった）


### エスケープシーケンス

プログラミング言語には、特別な扱いを受ける文字があります。例えば、echoコマンドで、「Value of ABC is "123".」のように "(ダブルクォート)を出力する方法を考えてみましょう。


$ ABC=123}
$ echo "Value of ABC is "$ABC"."}
Value of ABC is 123.
($ABCを""で囲いましたが、""が表示されません)
$ echo "Value of ABC is \"$ABC\"."}
Value of ABC is "123".
(表示したい"の直前に「\」を付けることで"を表示できます)

他にも方法はないでしょうか。

$ echo 'Value of ABC is "$ABC".'}
Value of ABC is "123".
(この例のように、文字列全体を'(シングルクォート)で囲むことでも"(ダブルクォート)を表示できます)
$ echo "Value of ABC is \$ABC."}
Value of ABC is $ABC.
（ダブルクォートで囲んだ文字列内で「$」をそのまま表示したい場合にも直前の「\」で可能です）

このように、シェルスクリプトでは、\（バックスラッシュ）はエスケープ文字と呼ばれ、特別な文字で直後の１文字の扱いを変更します。使用する引用符との組み合わせで、文字の扱いを変えたい場合に有効です。
\（バックスラッシュ）は改行コードにも有効です。\（バックスラッシュ）を行末に付与することで、文字列の途中で折り返すことができます。適切に改行を入れることでコマンドの視認性を向上できます。

$ echo "I am a cat. As yet I have no name."}
I am a cat. As yet I have no name.
$ echo "I am a cat.\\}
>  As yet I have no name."}
I am a cat. As yet I have no name.
（途中でバックスラッシュを入れても改行は無視され同じ結果となる）


バックスラッシュによる改行は、シェルスクリプト内でも使うことができます。バックスラッシュは本来＼ですが、多くの日本語環境では￥と表示されるので、本教科書でも￥で表示しています。環境によっては＼と表示されます。

$ vi escape.sh}

#!/bin/bash

echo "I am a cat. \
As yet I have no name."

$ ./escape.sh}
I am a cat. As yet I have no name.


\（バックスラッシュ）には、他の用途もあり、次に続く１文字とセットで特別な意味を持つ文字列とする、エスケープシーケンスという手法があります。

よく使用されるものとして、\t(タブ)、\n(改行)、\ooo(oは数字で８進数表記の文字)があります。

echo コマンドでエスケープした文字を解釈するオプション -e で試してみましょう。

$ echo -e "I am a cat. \nAs yet I have no name\041"}
I am a cat.
As yet I have no name!
（\nは改行に変わり、\041は!になりました。）

### sourceコマンド

sourceコマンドは、bashなどのシェルの内部コマンドで、指定されたファイルを読み込んでシェル環境を設定します。ファイル内容はシェルコマンドと解釈して実行します。

一般的な用途としては、シェルの環境設定ファイルである".bashrc"や".bash_profile"などを設定変更後、ログインしなおさずに設定を現在のシェル上で有効にする場合に使われます。

実行例のようにsetshというシェルスクリプトを作成、$abcという変数にxyzを定義して、sourceコマンドで読み込んでみましょう。


○実行例

//olnum[1]
 1. シェルスクリプト「set.sh」を用意
$ cat set.sh
（set.sh の内容確認）

#!/bin/bash
abc=xyz
echo $abc


//olnum[2]
 1. $abcをechoコマンドで出力
$ echo $abc
（$abcには何も格納されてないため、何も表示されない）


//olnum[3]
 1. set.shスクリプトを実行
$ ./set.sh
xyz
（スクリプト内で設定された変数abcの値がechoで出力された）

set.shにはecho文が記述されているため、その値が出力される。

//olnum[4]
 1. $abcをechoコマンドで出力
$ echo $abc
（変数abcへの値の設定はスクリプト内でしか有効でないので、何も表示されない）


//olnum[5]
 1. sourceコマンドでset.shを読み込む
$ source set.sh
xyz
（スクリプト内で設定された変数abcの値がechoで出力された）


//olnum[6]
 1. sourceコマンドで読み込んだことにより、set.sh の終了後も変数abcに値が格納されたまま
$ echo $abc
xyz



## 条件分岐

プログラミングでは、条件にそって挙動を切り替える「条件分岐」を多用します。条件分岐はすべてのプログラミング言語に存在する機能です。もちろんシェルスクリプトでも利用することができます。

### if文

比較などによる条件分岐を行なう場合はif文を利用します。文法は次の通りです。

書式
if 条件式1 then ... elif 条件式2 ... else ... fi


elif...の部分とelse...の部分は省略可能です。elifは、別の条件(条件式2)で判断したい場合に利用します。
elseは条件が全てあてはまらなかった場合、実行されます。if文はfiで終了します。

条件式
if文で利用される条件式には、次のような文法があります。

//tsize[20,70]
//table[tbl13][文字列比較を行なう演算子]{
演算子	比較内容	
---------------------------------------------------------------------------
a ## b	aとbが等しければ真
a != b	aとbが等しくなければ真


//tsize[20,70]
//table[tbl14][数値比較を行なう演算子]{
演算子	比較内容	
---------------------------------------------------------------------------
a -eq b	aとbが等しい（equal to）ければ真
a -ne b	aとbが等しくなければ（not equal to）真
a -ge b	aがb以上（greater than or equal to）であれば真
a -le b	aがb以下（less than or equal to）であれば真
a -gt b	aがbより大きい（greater than）値であれば真
a -lt b	aがb未満（less than）であれば真



### ファイル属性の確認

ファイル属性の確認は次のように行います。

書式
if test -d パス ; then.....


-dの部分がファイル属性確認の演算子にあたります。-dはディレクトリであるかの判定を行なうので、このif文全体で、「パスがディレクトリであれば真の値を返す」という条件式になります。
ファイルの属性確認演算子は次の以下のようなものが利用できます。

//tsize[30,70]
//table[tbl15][ファイル属性の確認を行なう演算子]{
演算子	内容	
---------------------------------------------------------------------------
-f ファイル名	通常ファイルなら真
-d ファイル名	ディレクトリなら真
-e ファイル名	ファイルが存在すれば真
-L ファイル名	シンボリックリンクなら真
-r ファイル名	読み取り可能ファイルなら真
-w ファイル名	書き込み可能ファイルなら真
-x ファイル名	ファイルが存在して、実行権限があれば真
-s ファイル名	サイズが0より大きければ真


なお、testコマンドは @<tt>{[ ]} を使って記述することもできます。

書式
if [ 条件節 ]; then ...
if test 条件節 ; then ....


ファイルに関する比較演算子は属性以外にもあります。詳細についてはmanコマンドでtestコマンドの項目を参照してください。
man test


### 複数の条件を重ねる

条件分岐の場合、複数の条件を重ねることができます。条件Aと条件Bが同時に成立している必要があるときは、「条件A”かつ”条件Bが成立」ということで、論理積(=AND)が用いられます。同じく「条件A”もしくは”条件Bが成立」の場合は、論理和(=OR)が用いられます。
シェルスクリプトにおいて、論理積・論理和の書き方は2通り存在します。

### 論理積

論理積は-aを用いる場合と、&&を用いる場合があります。それぞれの利用形式は次の通りです。

書式
[条件A -a 条件B -a 条件C ] ....
[条件A] && [条件B] && [条件C] ...


-aと&&は、それぞれ@<tt>{[ ]}の内側か外側かで、使われ方が変わることに気をつけてください。

### 論理和

論理和を表す記号は、やはり2通り存在します。-oと||です。利用形式は次の通りです。

書式
[条件A -o 条件B -o 条件C ] ....
[条件A] || [条件B] || [条件C] ...


### 一対多の条件分岐

一対多の分岐を行なうことを考えてみましょう。if文を用いた場合、一対多の分岐は以下のようになります。

if 条件式 then
	:
elif 条件式 then
	:
elif 条件式 then
	:
	:
fi

シェルスクリプトでは、case文が用意されており、一対多の分岐が記述できるようになっています。

書式
case 変数 in
	値A)
			処理1;;
	値B)
			処理2;;
esac


変数の値が値Aのとき、処理1が実行されます。最後はcase文の逆からの記述であるesacで終わっていることが重要です。
値はパイプ記号（|）で区切って複数指定することができます。

$ cat case.sh}
（次のようにcase.shを作成して実行します）

#!/bin/bash

case $1 in
        a|A)
           echo "引数にaまたはAが入力されました";;
        b|B)
           echo "引数にbまたはBが入力されました";;
esac


これを実行すると、以下のような実行結果になります。

$ ./case.sh a}
引数にaまたはAが入力されました
$ ./case.sh B}
引数にbまたはBが入力されました


また、どの値にもマッチしなかった場合の処理を記述するには、値にアスタリスク（*）を用います。

$ cat defaultcase.sh}		次のようにdefaultcase.shを作成し、実行します。
#!/bin/bash

case $1 in
        1)
           echo "引数に1が入力されました";;
        2)
           echo "引数に2が入力されました";;
        *)
           echo "1,2以外が入力されました";;
esac


これを実行すると、以下のような実行結果になります。

$ ./defaultcase.sh 1}
引数に1が入力されました
$ ./defaultcase.sh 2}
引数に2が入力されました
$ ./defaultcase.sh 0}
1,2以外が入力されました
（どの条件にもマッチしない場合、値*の処理が実行されます）


## 繰り返し

プログラミングにおいて、条件分岐と同じくらい重要な機構が、この繰り返しです。同じ処理を繰り返し行い、ある条件が成立したときに終了する、という形式が用いられています。
シェルスクリプトで用いられている繰り返しは、以下の3通りです。しっかり学習しましょう。

### for文

for文は値を列挙し、それを対象に処理を繰り返します。

書式
for 変数 in 値のリスト
do
	処理
done


値のリストとは、文字を羅列したものもあれば、実行結果を使うこともできます。

$ for i in a b c d}
> do
> 	echo $i
> done
a
b
c
d


これは、値のリストとして'a b c d'が渡され、まずi=aを行いecho $i、次にi=bを行いecho $iを・・・と繰り返した結果です。値のリストとしてコマンドの実行結果を使うことができ、以下のようにiにlsの実行結果を代入してループが実行されます。

for i in `ls`



### while/until文

while文は、条件が成立している間ループを繰り返す（条件が成立しなくなったら終了）という処理で利用されます。until文はそれの反対で、条件が成立してない間ループを繰り返す（条件が成立したら処理を終了）、という用途に用いられます。

書式
while 条件式
do
	処理
done
until 条件式
do
	処理
done


C言語のforのようなループ文をシェルスクリプトで実現するには、exprコマンドを用いてループカウンタ用の変数をインクリメント（またはデクリメント）しながら、while/until文で処理を行ないます。

次のような内容のloop.shを作成し、実行してみましょう。
$ cat loop.sh}

#!/bin/bash

count=1
while [ $count -le 10 ]
do
        echo "この処理は$count回実行されました"
        count=`expr $count + 1`
done


count=1で、カウンタ用の変数countに初期値1を設定します。
while @<tt>{[ $count -le 10 ]}で、シェル変数countが10以下の間、処理を繰り返します。

これを実行すると、以下のような実行結果になります。

$ ./loop.sh}
この処理は1回実行されました
この処理は2回実行されました
この処理は3回実行されました
この処理は4回実行されました
この処理は5回実行されました
この処理は6回実行されました
この処理は7回実行されました
この処理は8回実行されました
この処理は9回実行されました
この処理は10回実行されました


### select文

select文は、ユーザに対し数値による入力を促します。

書式
select 変数 in リスト
do
	処理
done


実際に動作例を示してみます。

select name in  "apple" "banana" "orange"
do
	echo "You selected $name";
done


これを実行すると、以下のような実行結果になります。

1) apple
2) banana
3) orange
$? 1}
You selected apple
（「Ctrl」Cで中止）


1-3を入力すると、do～done内部が実行されます。

### 繰り返しの制御

breakやcontinueを用いることで、繰り返しを制御することができます。breakは繰り返しを終了して、continueは繰り返しの先頭に戻る役割があります。

$ cat ./sample.sh}
while true
do
  echo "Continue? (y/n)"
  read input
  case $input in
    n) break
       ;;
    y) continue
       ;;
    *) echo "Please input y or n."
       ;;
    esac
done


これを実行すると、以下のような実行結果になります。

$ ./sample.sh}
Continue? (y/n)
y}
（yを入力）
Continue? (y/n)
（繰り返しの先頭に戻る）
a}
（y,n以外を入力）
Please input y or n.
Continue? (y/n)
n}
（nを入力）
$
（繰り返しを終了する）



## サブルーチン

プログラミングをする上で、一連の処理をまとめて、再利用できるようにしたものを、サブルーチンといいます。サブルーチンは言語体系によりさまざまな呼ばれ方をしていて、シェルスクリプトでは関数と呼ばれています。

### 関数

関数は、引数とよばれるデータを与え、処理をして結果を返すという機能の集まりです。書式は次のようになっています。

書式
function 関数名
{
	処理
}


関数名()
{
	処理
}


両者とも働きは同じです。引数は、実行時に関数名に続けて記述します。引数は、関数の内部で$1, $2で参照することができます。

### return文

シェルスクリプトの関数で、結果を返すときはreturn文を実行します。

書式
return 変数名


return文を実行すると、関数内での処理はそこで終了し、変数が関数の呼び出し元に返されます。

## 実際のシェルスクリプト

それでは、実際に稼働しているシェルスクリプトを見てみましょう。
（今回はCentOS 7の起動スクリプトを例にあげています。他のディストリビュージョンおよびCentOSのバージョンによっては若干内容が異なる場合があります。）

### 起動スクリプト

今回は/etc/init.d/networkを参考にします。CentOS 7では、サービスの起動は SysV init から systemd に置き換えられましたが、/etc/init.dに SysV init 後方互換のスクリプトがあります。

17行目
 17 . /etc/init.d/functions


/etc/init.d/functionsというファイルを読み込みます。/etc/init.d/functionsは、/etc/の中に入っているさまざまなシェルスクリプトが、共通して利用できる便利な関数が入っています。それを有効にするために、最初の処理として17行目が実行されます。

33〜34行目
 33 # if the ip configuration utility isn't around we can't function.
 34 [ -x /sbin/ip ] || exit 1

34行目は、下記の書式に基づいた動作をします。

書式
コマンド１ && コマンド２
    コマンド１が正常終了した場合、コマンド２を実行

コマンド１ || コマンド２
    コマンド１が異常終了した場合、コマンド２を実行

コマンド１ && コマンド２ && ... && コマンドＮ || コマンドＹ
    コマンド１から実行し、正常終了する限り && の右に進み、異常終了した段階でコマンドＹを実行


最初の文字「［ 」は、/usr/binディレクトリにあるコマンドで、testコマンドと同じ機能を持ちます。また、bash のビルトインコマンドとしても存在します。

$ which \[
/usr/bin/[

書式に従い、34行目は［ -x /sbin/ip ］が異常終了した場合に「||」の右側のコマンド「exit 1」を実行します。正常終了した場合は次の行に進みます。
つまり、/sbin/ip が実行可能なファイルとして存在すれば、処理を先に進めますが、/sbin/ipを実行できない条件では異常として終了します。

exitの後に続く数値は、シェルスクリプトの終了コードです。終了コードは親プロセスに返すのでリターンステータスとも呼ばれます。通常はスクリプトが正常に終了する場合に0を、それ以外の場合にエラーコードを示す値を設定します。省略した場合には0が設定されます。設定された値は特殊変数「?」に格納され、「$?」にて参照することができます。

34行目は、testコマンドを使用して下記のように書き換えることができますが、［ ］ を使用することで、簡潔に記述できる利点があります。
if test ! -x /sbin/ip ; then
        exit 1
fi

 
　64〜67行目
#tell NM to reload its configuration
if [ "$(LANG=C nmcli -t --fields running general status 2>/dev/null)" = "running" ]; then
        nmcli connection reload
fi

nmcli コマンドの前に LANG=C をつけています。Linuxは、国際化されたOSで、言語設定(locale)によって、出力メッセージの言語を切り替えることができます。
上記では、nmcli -t --fields running general status 2 の結果が running であるか否かで分岐していますが、利用者の言語設定によってコマンドの結果文字列が変わってしまうのを回避するために、このコマンド実行でのみ強制的にLANG=Cに設定しています。言語設定が異なると下記のように結果が変わります。
よく使われるテクニックなので覚えておくと役に立ちます。

(LANGにPOSIXのデフォルトロケールのCを指定した場合)
$ LANG=C nmcli -t --fields running general status 2
running
(LANGにイタリア語のロケールの it_IT を指定した場合)
$ LANG=it_IT nmcli -t --fields running general status 2
in esecuzione



### 関数のシェルスクリプト

/etc/init.d/functionsというファイルがあります。/etc/init.d/networkの17行目でも説明したとおり、シェルスクリプトの便利な関数を集めたシェルスクリプトです。その中で記述されている関数を1つ説明します。

586行目
is_ignored_file() {
	case "$1" in
		*~ | *.bak | *.orig | *.rpmnew | *.rpmorig | *.rpmsave)
			return 0
			;;
	esac
	return 1
}


is_ignored_file()という関数は、/etc/init.d/networkの中で無視したいファイル名に該当するかどうかのチェックを行っており、引数の1つ目($1)にファイル名が代入されます。
case文で引数に格納されたファイル名が *~, *.bak, *.orig, *.rpmnew, *.rpmorig, *.rpmsave （*は0文字以上の任意の文字列を意味します）のいずれかの条件に該当していれば0（真）を返し、該当していなければ1（偽）を返します。

無視したいファイル名が増えた場合、例えば.abcで終わる場合が出たとします。そのときは*.abcのエントリをここで加えると、/etc/init.d/networkのみならず、is_ignored_file()を呼んでいる関数全部で同等の機能が反映されます。
関数の利用は、呼ばれているプログラムの機能を一括で更新できる、という利点があることを理解してください。

この関数は/etc/init.d/network以外でも利用できます。


## デバッグ

作成したプログラムが思ったように動作しない場合、どこに問題があるのか調べる必要があります。これをデバッグといいます。プログラムの所々に、変数を表示させるコードや、プログラムの走行ルートを表示させるコードを埋め込む必要があり、非常に労力がかかります。よって多くのプログラム言語には、デバッグを支援するツールが用意されています。シェルスクリプトにも、スクリプトをデバッグモードで動かすためのコマンドが用意されています。

### shコマンド

sh自身はシェルを起動するコマンドですが、-xオプションを付けて引数にシェルスクリプトを指定すると、コマンドや変数の中身を表示しながらスクリプトを実行します。繰り返しの項で使用したsample.shをshコマンドにて実行してみましょう。

$ sh -x ./sample.sh}
+ true
+ echo 'Continue? (y/n)'
Continue? (y/n)
+ read input
y}
（yを入力）
+ case $input in
+ continue
+ true
+ echo 'Continue? (y/n)'
Continue? (y/n)
+ read input
n}
（nを入力）
+ case $input in
+ break

